WEBVTT

00:00.950 --> 00:02.270
ยินดีต้อนรับกลับ.

00:02.270 --> 00:03.190
เป็นอย่างไรกันบ้าง

00:03.260 --> 00:04.030
คุณได้รับมัน.

00:04.040 --> 00:07.040
มันเป็นคำถามที่ยากไหม

00:07.100 --> 00:14.120
อย่าผิดหวังมากเกินไปถ้าคุณไม่สามารถหาคำตอบได้คำถามเหล่านี้มีความหมายที่จะทำให้คุณยืดเยื้อ

00:14.330 --> 00:17.360
หากพวกเขาง่ายเกินไปคุณจะไม่ได้เรียนรู้อะไรเลย

00:22.930 --> 00:28.900
เรามาเริ่มต้นด้วยวิธีการที่ไร้เดียงสาซึ่งเป็นแนวทางแรกที่นึกถึง

00:29.750 --> 00:36.280
สำหรับฉันคนแรกที่จะเป็นแบบซ้อนสำหรับลูป

00:36.470 --> 00:37.660
มามีฟังก์ชั่นกัน

00:37.700 --> 00:39.170
ฉันจะโทรหาก่อน

00:42.530 --> 00:45.850
ตัวละครที่เกิดขึ้น

00:46.060 --> 00:47.940
มันจะรับอินพุต

00:48.670 --> 00:53.140
และเนื่องจากเราได้พูดคุยกันแล้วฉันจะไม่ทำการตรวจสอบอินพุตใด ๆ

00:53.140 --> 00:59.860
เราสามารถสรุปได้ว่าเราจะได้อาร์เรย์ที่เป็นตัวเลขเสมอ

00:59.870 --> 01:05.670
ฉันจะวนซ้ำอีกครั้งและโอ้วฉันทำไปหลายครั้งแล้ว

01:05.750 --> 01:09.310
ฉันหวังว่าคุณจะป่วยและเบื่อที่จะวนซ้ำผ่านอาร์เรย์

01:10.620 --> 01:19.240
แต่อย่างน้อยตอนนี้เราเป็นนายของลูป

01:19.470 --> 01:20.700
บวกบวก

01:21.470 --> 01:28.330
ดังนั้นที่นี่ในลูปแรกเราจะหยิบไอเท็มแรกในอาร์เรย์และลองเรียกใช้ฟังก์ชันนี้

01:28.330 --> 01:30.920
ดังนั้นเรามีที่นี่

01:30.920 --> 01:32.080
ดีและง่าย

01:33.300 --> 01:35.710
และทำให้เราเห็นภาพที่ดี

01:35.830 --> 01:42.600
ดังนั้นฉันจะวนผ่านรายการแรกจากนั้นครั้งที่ห้าหรือครั้งที่สองที่สามที่สี่และจะดำเนินการต่อไป

01:43.000 --> 01:48.490
ฉันต้องการคว้าไอเท็มนี้แล้วทำลูปอื่นแล้วตรวจสอบสองต่อห้า

01:48.610 --> 01:53.550
สองต่อหนึ่งสองกับสองแล้วบอกว่านั่นคือหนึ่ง

01:53.950 --> 02:02.520
หากไม่พบสิ่งใดเลยมันจะไปยังห้าถัดไปจากนั้นเปรียบเทียบ 5 กับ 1 1 ถึง 2 2 2 3 และอื่น ๆ

02:03.370 --> 02:15.580
ดังนั้นอีกครั้งฉันจะคัดลอกและวางครั้งนี้เพราะเราทำลูปมาสี่อันแล้วก็เปลี่ยนตัวแปรเป็นเจ

02:15.620 --> 02:19.940
เราจะเริ่มต้นที่ 1 เพราะเราไม่ต้องการเปรียบเทียบสองถึงสอง

02:19.940 --> 02:21.710
เราต้องการเปรียบเทียบสองถึงห้า

02:21.770 --> 02:27.020
ในการเริ่มต้นดังนั้นเราจึงข้ามการวนซ้ำซึ่งจะช่วยเรา

02:27.650 --> 02:39.570
ฉันจะบอกว่า Jay ที่นี่และ J

02:39.570 --> 02:46.120
plus

02:46.180 --> 02:59.880
plus ทีนี้คุณบางคนอาจจะถูกจับที่นี่เพราะถ้าเรามีวิธีที่เป็นอยู่ในตอนนี้และคุณคอนโซลบันทึกการวนรอบนี้คุณจะเห็นว่ามันทำงานไม่ถูกต้อง ทุกครั้งที่สิ่งนี้เลื่อนด้านนอกสำหรับการเลื่อนแบบวนรอบจากสมมติว่าศูนย์เป็นหนึ่งถัดไปดัชนีหนึ่งที่เจย์จะถูกรีเซ็ตเป็น 1

03:00.020 --> 03:05.950
ดังนั้น 5 จะได้รับการเปรียบเทียบกับ 5 และฟังก์ชันจะถือว่าเป็นห้า

03:05.960 --> 03:08.850
ตัวละครซ้ำ

03:09.030 --> 03:22.260
ดังนั้นเคล็ดลับเล็กน้อยที่นี่คือการทำ pi บวกหนึ่งที่เรามักจะไปทางขวาของที่ HIAS ดัชนีแรก

03:22.590 --> 03:34.260
ถ้าเราวนลูปและเราอยู่ที่นี่ลูปย่อยการวนซ้ำซ้อนกันจะดูที่ฉันบวก 1

03:34.340 --> 03:42.360
มันจะเป็นการเปรียบเทียบสองถึงสามสองถึงห้ากับผมเพราะเราได้เปรียบเทียบกับ 2 2 5 2 5 5 2 2

03:42.360 --> 03:46.830
1 2 2 และลูปก่อนหน้า

03:46.830 --> 03:47.400
เอาล่ะ

03:47.610 --> 03:49.700
เราได้ทำสิ่งนี้ในที่นี่แล้ว

03:49.740 --> 03:54.120
เราสามารถทำคำสั่ง if ที่บอกว่าเป็นส่วนหนึ่งได้

03:54.510 --> 04:00.970
ไม่เท่ากับอินพุต J ที่เท่ากับ 5

04:01.040 --> 04:04.320
สองเท่ากับ 1 เท่ากับ 2 หรือไม่

04:04.640 --> 04:12.860
หากนั่นเท่ากับแล้วเพียงแค่กลับมาและใส่อย่างอื่น

04:12.880 --> 04:22.940
หากเราทำงานทั้งหมดนี้และไม่มีอะไรเกิดขึ้นเราก็สามารถส่งคืนโดยไม่ได้กำหนด

04:23.020 --> 04:24.220
ลองดูว่ามันใช้งานได้ไหม

04:24.340 --> 04:44.030
ฉันจะเรียกใช้และฉันจะได้สองที่ยอดเยี่ยมเกิดอะไรขึ้นถ้าฉันเปลี่ยนมันเป็นหนึ่งถ้าฉันเรียกใช้นี้ฉันได้หนึ่งที่สมบูรณ์แบบถ้าฉันทำเพียงรายการเดียวในอาร์เรย์ .

04:44.060 --> 04:44.990
ดีแล้ว.

04:45.230 --> 04:50.230
ถ้าฉันทำ 1 1 หรือ 1 ฉันจะได้ 1

04:50.230 --> 04:50.760
เยี่ยมมาก

04:50.770 --> 04:55.250
ถ้าฉันต้องการฉันได้รับยอดเยี่ยม

04:55.290 --> 05:03.410
ดูเหมือนว่าจะใช้งานได้ดีและเรียบง่าย แต่อย่างที่คุณเห็นที่นี่เราไม่มีประสิทธิภาพ

05:03.480 --> 05:13.400
เรามีลูปซ้อนกันซึ่งน่าจะเรียกว่าโอ้นี่คือทั้งหมดและกำลังสอง

05:13.480 --> 05:24.650
และถึงแม้ว่าในทางเทคนิคแล้วเรามักจะวนลูปที่มีประสิทธิภาพมากกว่าเดิมเล็กน้อยเพราะฉันบวกกับที่ฉันไม่ได้วนซ้ำสองครั้งในอาเรย์ทั้งหมด

05:25.590 --> 05:32.510
ในที่สุดเมื่อคุณลบค่าคงที่และทำให้สิ่งต่าง ๆ ง่ายขึ้นมันจะยังคงเป็น 0 และกำลังสอง

05:32.550 --> 05:36.100
ดังนั้นเราจะแก้ปัญหานี้โดยใช้ตารางแฮชได้อย่างไร

05:37.460 --> 05:41.830
เรามาสร้างฟังก์ชั่นใหม่กันดีกว่า

05:43.180 --> 05:46.690
เราจะเรียกฟังก์ชั่นนี้ด้วยชื่อเดียวกันในเวลานี้

05:46.690 --> 05:54.330
หมายเลขสองรุ่น 2 มันจะได้รับการป้อนข้อมูล

05:54.540 --> 06:06.800
และเปลี่ยนกรณีทดสอบของเราให้เหมือนกันก่อนหน้านี้เราทำอะไรได้บ้าง

06:07.680 --> 06:15.440
ลองใช้ตารางแฮชหรือวัตถุเพื่อทำสิ่งที่น่าสนใจ

06:15.600 --> 06:24.870
นั่นคือการมีสิ่งเหล่านี้ทั้งหมดในขณะที่เราวนซ้ำทีละรายการดังนั้นวนรอบรายการทั้งหมดเพิ่มลงในตารางแฮ

06:25.170 --> 06:32.670
และในขณะที่เรากำลังทำเช่นนั้นเราสามารถตรวจสอบเพื่อดูว่าทรัพย์สินมีอยู่แล้วหรือมีกุญแจอยู่

06:33.520 --> 06:38.650
เราเพิ่มสองเข้าไปในตารางแฮชจากนั้นห้าตารางแฮช

06:38.680 --> 06:50.010
และเมื่อเราพยายามเพิ่มสองตัวเราสามารถเรียกใช้คำเตือนว่าเรามีสองเป็นกุญแจแล้วดังนั้นการใช้ตรรกะนั้นมาดูกันว่าเราสามารถใช้

06:50.050 --> 06:52.770
ฉันจะสร้างแผนที่

06:52.840 --> 06:58.980
ตอนนี้เราจะเรียกมันว่าแผนที่แฮชเพราะกุญแจจะไม่ซ้ำกัน

06:58.990 --> 07:13.290
มันจะไม่ปล่อยให้กุญแจซ้ำซ้อนและเราสามารถทำลูปของเราได้

07:13.690 --> 07:39.500
และในวงนี้สิ่งที่เราจะทำคือบอกว่าแผนที่และเราสามารถตรวจสอบในแผนที่นี้ถ้ามันว่างเปล่าตอนนี้การเช็คอินครั้งแรกที่นี่ฉันอยากจะบอกว่าทรัพย์สินหรือถ้ากุญแจมีอยู่แล้วฉันต้องการคืน ชิ้น

07:40.420 --> 07:42.880
เพราะเราไม่จำเป็นต้องทำงานอีกต่อไป

07:43.300 --> 07:52.800
ทันทีที่เราพบกุญแจที่มีอยู่แล้วในตารางแฮชของเราหยุดการวนซ้ำทั้งหมดและเพิ่งกลับมา

07:52.840 --> 07:55.330
ในกรณีนี้เราต้องการกลับไป

07:55.450 --> 08:08.970
ที่ดัชนี 0 1 2 3 มันจะกลับมาแล้วบอกว่า 2 เพราะคีย์นี้มีอยู่แล้ว

08:09.150 --> 08:17.500
วิธีที่เราทำในการตรวจสอบ IF ก็แค่บอกว่าและใส่เพราะจำไว้ว่าสิ่งนี้จะเท่ากับ 2

08:17.500 --> 08:21.240
เมื่อเราวนรอบมัน

08:23.400 --> 08:33.320
หากมีอยู่แล้วส่งคืนมิฉะนั้นเราจะเพิ่มลงในแผนที่ของเรา

08:33.410 --> 08:41.400
ดังนั้นอินพุตโดยจะเท่ากับและค่าสามารถเป็นอะไรก็ได้

08:41.400 --> 08:44.480
เราจะทิ้งมันไว้ที่ฉันซึ่งเป็นดัชนี

08:44.820 --> 08:54.930
ดังนั้น 2 จะเท่ากับ 0 5 จะเท่ากับ 1 1

08:54.930 --> 08:56.620
จะต้องมีเพียงแค่คอนโซลบันทึกที่นี่เพื่อดูว่าเกิดอะไรขึ้น

08:56.790 --> 09:07.240
แต่ฉันต้องการคืนค่าไม่ได้กำหนดในตอนท้ายในกรณีที่ไม่มีสิ่งนี้เกิดขึ้นในกรณีที่ไม่มีการแข่งขัน

09:07.250 --> 09:12.220
ดังนั้นในตอนท้ายของ for for loop เราจะยกเลิกบันทึกจุด

09:12.310 --> 09:15.850
Napp และดูสิ่งที่เรามี

09:15.970 --> 09:20.230
ฉันจะวิ่งและฉันได้ห้า

09:20.520 --> 09:23.700
และไม่มีบันทึกว่าเกิดอะไรขึ้นที่นี่

09:24.150 --> 09:32.610
ดีถ้าเราคอนโซลเข้าสู่ระบบ Ophir แทนและดูสิ่งนี้ให้เราและฉันจะได้รับ undefined undefined

09:36.360 --> 09:43.460
undefined ศูนย์ und หนึ่ง

09:43.500 --> 09:44.910
นั่นหมายความว่าอย่างไร.

09:44.910 --> 09:55.670
โปรดจำไว้ว่าเราวนลูปผ่านที่นี่และเรากำลังบอกว่าเฮ้มีอยู่จริงด้วย

09:55.790 --> 09:57.940
อินพุตเป็นศูนย์หรือไม่

09:57.980 --> 10:01.530
ซึ่งจะมีอยู่เป็นกุญแจ

10:02.030 --> 10:08.090
ดังนั้นมันจึงบอกให้ Napp dot ทราบว่ามันมีอยู่จริง

10:08.190 --> 10:16.200
และเพราะนั่นไม่ได้มีอยู่เราได้รับการกำหนดและมันจะไปต่อไปเฮ้มีอยู่ห้าตัว

10:16.260 --> 10:17.210
ไม่มันไม่

10:17.220 --> 10:19.320
เฮ้มีอยู่จริง

10:19.320 --> 10:20.220
ไม่มันไม่

10:20.340 --> 10:22.320
เฮ้มีอยู่จริงด้วย

10:22.350 --> 10:32.770
และทันทีที่ตรวจสอบอีกครั้งมันจะบอกว่าฉันมีอยู่แล้ว

10:32.860 --> 10:37.640
มันอยู่ที่ดัชนี 0

10:37.690 --> 10:40.390
ดังนั้นนี่คือการทำงาน

10:40.630 --> 10:53.190
อย่างไรก็ตามเนื่องจากเมื่อนี่เป็นศูนย์วิธีการใช้งานจาวาสคริปต์มันจะทำให้ศูนย์อยู่ที่นี่ แต่ในคำสั่ง IF เป็นศูนย์คือสิ่งที่เราเรียกว่า falsie และ Javascript และสิ่งที่เกี่ยวข้องกับประเภท

10:53.580 --> 11:00.600
coarsen และ Javascript ที่ผู้คนจำนวนมากรำคาญกับภาษา

11:00.600 --> 11:03.930
.

11:03.930 --> 11:12.780
ดังนั้นสิ่งที่เราต้องทำก็คือเพื่อให้แน่ใจว่าเราระบุว่าเราต้องการให้สิ่งนี้ไม่เท่ากัน

11:12.840 --> 11:18.690
ดังนั้นทันทีที่มันไม่เท่ากับ undefined ฉันต้องการให้คุณส่งคืนสินค้านี้

11:18.710 --> 11:34.900
ทีนี้ถ้าเราทำสิ่งนี้เราจะได้สองอย่างซึ่งดีมากถ้าเรา Konsole dot ล็อกแผนที่และเรียกใช้ที่ด้านล่างที่นี่

11:34.900 --> 11:43.950
ดังนั้นเราเห็นการวนซ้ำจริงที่เกิดขึ้นเราเห็นว่ามันเพิ่มเข้ากับดัชนี 0 จากนั้นเข้าสู่ดัชนี 0 และ 5 ดัชนี

11:43.950 --> 11:46.280
1

11:46.590 --> 11:54.870
ต่อไปเรื่อย ๆ จนกว่ามันจะหยุดหลังจากวนรอบที่สามเพราะมันเจออีกครั้งมันจะตรวจสอบและบอกว่า 0 2

11:54.870 --> 11:57.480
มีอยู่แล้ว

11:57.480 --> 11:59.930
เพียงแค่ส่งคืน

11:59.950 --> 12:01.320
เท่ห์แค่ไหน

12:01.360 --> 12:13.110
เราเพิ่งทำสิ่งนี้ทั้งหมดด้วยการวนรอบเพียงครั้งเดียวซึ่งเร็วกว่าเวอร์ชั่นแรกของเราโดยใช้ตารางแฮช

12:13.110 --> 12:21.000
มันยอดเยี่ยมเพียงใดสำหรับฉันที่ทำสิ่งนี้และเห็นพลังของการเรียนรู้เกี่ยวกับ big-O

12:21.000 --> 12:29.300
และ hash table ได้ปรับปรุงความสามารถในการเข้ารหัสของเราเพียงแค่ทำให้ฉันตื่นเต้นจริงๆ

12:29.370 --> 12:33.960
เราทำให้ฟังก์ชั่นนี้มีความซับซ้อนของเวลาทั่ว

12:34.050 --> 12:43.530
เราได้ปรับปรุงด้วยข้อเสียเดียวเราได้เพิ่มความซับซ้อนของพื้นที่หน่วยความจำโดย

12:43.530 --> 12:59.850
O เนื่องจากเราสร้างวัตถุใหม่ในฟังก์ชันนี้ที่ต้องติดตามรายการทั้งหมดในอาร์เรย์และในกรณีที่แย่ที่สุดเมื่อมี ไม่มีการจับคู่มันจะผ่านรายการทั้งหมดของอาร์เรย์และเก็บข้อมูลนั้นไว้ในแผนที่

12:59.850 --> 13:07.140
ดังนั้นเราก็จะมีความแตกต่างจากรุ่นนี้ที่เราไม่ได้สร้างความซับซ้อนของพื้นที่ใด ๆ

13:07.140 --> 13:11.640
เราเพิ่งมีความซับซ้อนของพื้นที่ทั้งหมด

13:11.700 --> 13:16.910
ตอนนี้เรามีอีกเล็กน้อย แต่ในทางกลับกันเรามีฟังก์ชั่นที่เร็วขึ้น

13:18.200 --> 13:19.730
เด็ดมาก ๆ

13:19.880 --> 13:24.440
ตอนนี้เพื่อจบฉันต้องการให้คุณท้าทายครั้งสุดท้าย

13:24.950 --> 13:35.850
คุณจะเห็นว่าการใช้งานสองอย่างนี้จะเกิดอะไรขึ้นถ้าเรามีอะไรเช่นนี้

13:35.930 --> 13:41.210
คุณคิดว่าอักขระตัวแรกที่เกิดขึ้น

13:41.270 --> 13:57.170
ถ้าฉันรันสิ่งนี้ฉันจะได้ห้าเพราะห้าเกิดขึ้นเร็วกว่าสองสองเพราะวิธีที่เราใช้ฟังก์ชันที่สอง

13:57.170 --> 14:18.840
อย่างไรก็ตามถ้าฉันไปที่รุ่นแรกของฟังก์ชั่นของเราและเรียกใช้สิ่งนี้ฉันไปที่อืมทำไมก็ดีถ้าเราไปที่ส่วนแรกของฟังก์ชั่นของเราที่เราเห็นว่าวิธีที่เรากำลังทำสิ่งที่เรากำลังจะ วิธีที่แตกต่าง

14:19.160 --> 14:32.910
เรากำลังบอกว่าจับสองแล้วเปรียบเทียบสองกับห้าห้าห้าสองและสามกว่าห้าแล้วหนึ่งและสองสี่และจากนั้นย้ายไปที่ห้าในห้าและห้าและสองและอื่น ๆ

14:32.930 --> 14:40.400
และเนื่องจากวิธีที่เรานำไปใช้งานมันจะตรวจจับสองและสองเพราะวงรอบนอกมีดัชนี

14:40.730 --> 14:53.360
0 และมีสองตาที่จะผ่านวงก่อนที่จะเปรียบเทียบห้ากับห้าต่อ

14:53.470 --> 15:02.420
รุ่นที่สองของเรากับตารางแฮชที่เรามีรายการเหล่านี้ทั้งหมดและเราสามารถเปรียบเทียบ

15:02.560 --> 15:18.340
เมื่อเราจับพวกเขาทั้งหมดและนั่นเป็นอีกสิ่งที่ทรงพลังเมื่อคุณนึกถึงอาร์เรย์และตารางแฮชและวิธีการเปรียบเทียบสิ่งต่างๆ

15:18.340 --> 15:37.090
บางทีพวกเขาต้องการใช้เพื่อตรวจจับห้าและห้าก่อนที่คุณจะตรวจจับสองและสองดังนั้นคำถามโบนัสของฉันกับคุณถ้าคุณมีเวลาและความท้าทายเล็กน้อยคือการแปลงฟังก์ชันนี้

15:37.090 --> 15:41.050
นั่นคือการตรวจจับห้าและห้า

15:41.240 --> 15:43.930
คุณจะทำสิ่งนั้นอย่างไร

15:44.100 --> 15:47.550
คุณมักจะต้องทำสิ่งที่น่าสนใจที่นี่

15:48.890 --> 15:50.980
ขอให้โชคดีกับสิ่งนั้น

15:50.990 --> 15:58.440
พูดคุยกับคนอื่นในเรื่องความไม่ลงรอยกันในชุมชนของเราและดูว่าคุณสามารถคิดออกได้หรือไม่และฉันจะโพสต์วิธีแก้ปัญหาที่สร้างสรรค์เพื่อแก้ไขปัญหานั้น

15:58.630 --> 16:05.280
ในขณะที่นักเรียนส่งพวกเขาเพื่อดูว่าคนอื่น ๆ ได้ใช้สิ่งนี้อย่างไร

16:05.310 --> 16:08.300
แต่สำหรับตอนนี้ฉันคิดว่าเราสมควรได้รับการหยุดพัก

16:08.310 --> 16:09.590
ฉันจะดูในถัดไป

16:09.830 --> 16:10.250
ลาก่อน.
