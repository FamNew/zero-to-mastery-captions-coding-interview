WEBVTT

00:02.030 --> 00:09.740
อะไรคือโค้กที่ดีในตอนนี้คุณควรจะพูดคุยเล็กน้อย

00:09.980 --> 00:17.890
ฉันหมายถึงสามารถอ่านได้เรากำลังจะพูดถึงในหัวข้อถัดไป แต่ขนาดที่เราเข้าใจได้นั้นใหญ่มาก

00:18.320 --> 00:27.290
นี่คือสิ่งที่ไม่ได้เกลียดฉัน แต่ฉันอาจจะโกหกหรือทำตัวเรียบง่ายเล็กน้อย แต่ไม่มากนักดังนั้นอย่ากังวล Bouldon

00:27.290 --> 00:36.260
ว่าเมื่อฉันบอกว่าปรับขนาดได้จริง ๆ แล้วมีสองสิ่งที่เราต้องการพิจารณาในฐานะวิศวกร

00:36.260 --> 00:38.430
หนึ่งคือความเร็ว

00:38.480 --> 00:41.090
นั่นคือสิ่งที่เราพูดถึงมาจนถึงตอนนี้

00:41.180 --> 00:45.210
ความเร็วของรันไทม์ของเรานั้นเร็วแค่ไหนบนโค้ด

00:45.290 --> 00:49.730
ใช้เวลาในการเรียกใช้ฟังก์ชันนานเท่าใด

00:49.730 --> 00:52.820
มีค่าใช้จ่ายในการดำเนินงานจำนวนเท่าใด

00:53.270 --> 00:58.850
มีแง่มุมอื่นเมื่อพูดถึงเครื่องจักรกับทรัพยากรที่มีค่า

00:58.850 --> 01:06.860
หนึ่งคือเวลาและความเร็วของรหัสของเราและอื่น ๆ คือหน่วยความจำ

01:06.860 --> 01:11.800
คุณเห็นคอมพิวเตอร์มีหน่วยความจำ จำกัด

01:11.860 --> 01:17.860
ย้อนกลับไปในวันที่คอมพิวเตอร์เพิ่งเกิดความทรงจำมีราคาแพงมาก

01:17.860 --> 01:19.560
เรามีเพียงเล็กน้อยเท่านั้น

01:19.870 --> 01:25.280
และเมื่อเวลาผ่านไปเรามีหน่วยความจำมากขึ้นเรื่อย ๆ แต่มันก็ไม่สิ้นสุด

01:26.070 --> 01:36.090
คอมพิวเตอร์ของเราทำงานด้วยความเร็วซึ่งโดยปกติจะกำหนดโดย CPQ และหน่วยความจำตามจำนวนหน่วยความจำเช่น RAM

01:36.330 --> 01:40.000
และหน่วยความจำเข้าถึงโดยสุ่มของคอมพิวเตอร์

01:40.260 --> 01:43.810
และนั่นคือทรัพยากรที่มีค่าสองอย่าง

01:43.860 --> 01:46.110
ดังนั้นเราจะพูดถึงความทรงจำได้อย่างไร

01:46.110 --> 01:47.770
เราคุยกันเรื่องความเร็ว

01:47.820 --> 02:12.810
สิ่งที่เกี่ยวกับความทรงจำและข่าวดีก็คือหน่วยความจำค่อนข้างง่ายไม่ซับซ้อนเท่ากับความเร็วและมันใช้เวลาไม่นานที่เราจะเรียนรู้มากเท่าที่เรามีเกี่ยวกับความเร็วในขณะนี้ สิ่งที่ฉันต้องการให้คุณนำติดตัวไปตลอดอาชีพของคุณและสิ่งที่จะทำให้คุณเติบโตขึ้นในฐานะวิศวกรเพราะหลังจากนี้เมื่อคุณเขียนโค้ดคุณจะต้องมีสามสิ่งนี้อยู่ในใจ

02:12.810 --> 02:20.890
หนึ่งคือคุณกำลังจะเขียนโค้ดสะอาดอ่านง่ายที่คนอื่นสามารถอ่านที่สามารถบำรุงรักษาได้

02:20.910 --> 02:31.440
อีกอันคือความเร็วของรหัสที่เราเรียกว่าความซับซ้อนของเวลามีความซับซ้อนครั้งใหญ่ที่มีประสิทธิภาพ

02:31.440 --> 02:33.020
มันชั่งได้ดี

02:33.230 --> 02:39.910
แต่เราจะพูดถึงเสาหลักที่สามนี้อย่างรวดเร็วและนั่นคือความทรงจำ

02:40.010 --> 02:44.700
การใช้หน่วยความจำของรหัสคืออะไรหากใช้หน่วยความจำจำนวนมาก

02:44.780 --> 02:45.560
นั่นไม่ดีเลย

02:45.590 --> 02:49.430
เราอาจมีหน่วยความจำ จำกัด ในเครื่องของเรากับอันนี้

02:49.520 --> 02:54.830
เราใช้ big-O อีกครั้งเพื่อพูดคุยเกี่ยวกับความซับซ้อนของพื้นที่

02:54.830 --> 02:58.910
สัญกรณ์เดียวกัน แต่หัวข้อที่แตกต่าง

02:58.910 --> 03:00.080
หนึ่งคือพื้นที่

03:00.080 --> 03:02.220
อีกอันหนึ่งคือเวลาหนึ่งคือความเร็ว

03:02.300 --> 03:04.670
อีกอันหนึ่งคือหน่วยความจำ

03:04.670 --> 03:11.610
ฉันจะให้คุณดูตัวอย่างรวดเร็วแก้ปัญหาการเขียนโปรแกรมส่วนใหญ่

03:11.610 --> 03:14.830
มักจะมีการแลกเปลี่ยนระหว่างความเร็วและหน่วยความจำ

03:14.830 --> 03:22.220
คุณต้องการให้สิ่งต่าง ๆ ทำงานได้เร็วขึ้นจากนั้นคุณอาจต้องเสียสละหน่วยความจำมากขึ้นและต้องการหน่วยความจำน้อยลง

03:22.330 --> 03:27.120
ถ้าอย่างนั้นคุณอาจต้องเสียสละด้วยความเร็วที่เพิ่มขึ้น

03:27.290 --> 03:31.040
มาทำความรู้จักกับการวัดความซับซ้อนของอวกาศ
