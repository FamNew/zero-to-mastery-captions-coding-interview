WEBVTT

00:01.180 --> 00:07.600
เมื่อโปรแกรมทำงานมันมีสองวิธีในการจดจำสิ่งต่าง ๆ

00:07.600 --> 00:24.790
ฮีปและสแต็กกองมักเป็นที่ที่เราเก็บตัวแปรที่เรากำหนดค่าให้กับและกองมักเป็นที่ที่เราติดตามการเรียกใช้ฟังก์ชัน

00:24.840 --> 00:34.220
บางครั้งเราต้องการเพิ่มประสิทธิภาพสำหรับการใช้หน่วยความจำน้อยลงแทนที่จะใช้เวลาน้อยลงในการพูดคุยเกี่ยวกับหน่วยความจำหรือความซับซ้อนของพื้นที่

00:34.340 --> 00:37.540
คล้ายกันมากกับการพูดคุยเกี่ยวกับค่าใช้จ่ายเวลา

00:37.610 --> 00:47.150
เราเพียงแค่ดูขนาดรวมเทียบกับขนาดของอินพุตและดูว่ามีตัวแปรใหม่หรือหน่วยความจำใหม่ที่เรากำลังจัดสรร

00:47.360 --> 00:49.740
มีการใช้หน่วยความจำเท่าใด

00:49.790 --> 00:51.850
ลองดูตัวอย่าง

00:52.190 --> 01:03.640
จนถึงตอนนี้เราได้พูดคุยเกี่ยวกับความซับซ้อนของเวลาและวิธีที่เราต้องการบีบอัดสมมติว่ามีบางกล่องที่เราเพิ่งพูดถึงความเร็วและจำนวนการดำเนินการที่ต้องใช้

01:03.950 --> 01:12.800
แต่ในชีวิตจริงมีหน่วยความจำอีกปัจจัยหนึ่งและเรามีกล่องเล็ก ๆ

01:12.980 --> 01:17.410
สีชมพูนี้ว่าฟังก์ชันนี้สามารถรับอินพุตได้เท่าใด

01:17.510 --> 01:29.320
ตัวอย่างเช่นถ้าเรามีแปดร้อยกล่องที่เราต้องสร้างเพื่อเรียกใช้ฟังก์ชั่นนี้ได้ดีมีความจุ จำกัด และมันอาจล้น

01:29.480 --> 01:35.660
โดยวิธีต่าง ๆ เช่น Stack

01:35.660 --> 01:40.300
Overflow เป็นสิ่งที่เรากำลังจะพูดถึงและมันเป็นปัญหาเมื่อมันมาถึงความทรงจำบางสิ่งบางอย่างที่เราจะครอบคลุมเมื่อเราได้รับการเรียก

01:41.310 --> 01:45.300
สิ่งที่ทำให้เกิดความซับซ้อนของพื้นที่นี้

01:45.300 --> 01:50.060
โชคดีสำหรับคุณฉันเพิ่มมันลงไปใน chichi ของเรา

01:50.250 --> 02:06.290
สิ่งที่ทำให้เกิดความซับซ้อนของพื้นที่ในขณะที่การเพิ่มตัวแปรเพิ่มโครงสร้างข้อมูลเช่นอาร์เรย์วัตถุแฮชตารางอีกครั้งสิ่งที่จะพูดคุยเกี่ยวกับการเรียกใช้ฟังก์ชั่นและการจัดสรร

02:06.460 --> 02:08.280
คุณไม่จำเป็นต้องใช้ PIERI นี้

02:08.500 --> 02:14.290
แต่ลองเขียนโค้ดจริง ๆ แล้วแสดงตัวอย่างให้คุณดูในวิดีโอหน้า

02:14.320 --> 02:21.520
เราจะผ่านแบบฝึกหัดความซับซ้อนด้านอวกาศและหาวิธีที่เราจะให้สัญกรณ์ไปที่เรื่อง
