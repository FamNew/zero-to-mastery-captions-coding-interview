WEBVTT

00:02.180 --> 00:12.110
ยินดีต้อนรับกลับมาคุณอาจสังเกตเห็นบางสิ่งบางอย่างในขณะที่พูดถึงพวกเขาไปได้มากหมายความว่าเรากังวลเกี่ยวกับปัจจัยการผลิตขนาดใหญ่

00:12.420 --> 00:15.680
จุดสิ้นสุดของกราฟมีลักษณะเป็นอย่างไร

00:16.080 --> 00:24.360
ดังนั้นถ้าฟังก์ชั่นของเรากังวลเฉพาะอินพุตที่เล็กมาก ๆ หรือเรารู้ว่าอินพุตของเราจะเป็นเพียงสมมติว่าอาร์เรย์ของห้ารายการใหญ่ -O

00:24.360 --> 00:29.610
จะไม่สำคัญเท่าไร

00:29.610 --> 00:35.890
เพราะตรงนี้ถ้าองค์ประกอบมีขนาดเล็กทุกเส้นเหล่านี้เรียงกันเข้าด้วยกันพวกมันเหมือนกันทั้งหมด

00:35.970 --> 00:38.420
แต่นั่นคือชีวิตจริง

00:38.430 --> 00:48.420
ไม่เพราะมนุษย์เรามักจะคิดที่นี่และตอนนี้เรามักจะคิดว่าโอ้เว็บไซต์ของเรามีผู้ใช้ 100 คนเท่านั้น

00:48.480 --> 00:49.760
แค่นั้นแหละ.

00:49.800 --> 00:53.850
แต่ถ้าฐานผู้ใช้นั้นโตขึ้นจะเกิดอะไรขึ้นถ้าปัจจัยการผลิตของเราเพิ่มขึ้น

00:53.850 --> 00:59.760
เราไม่มีทางรู้ว่าเมื่อเราเขียนโค้ดเราต้องการเขียนโค้ดที่สามารถปรับขนาดได้เพื่อที่เราจะได้ไม่ต้องย้อนกลับไปแก้ไขสิ่งต่าง ๆ

00:59.760 --> 01:03.560
หรือเมื่อออกจากมือ

01:03.720 --> 01:12.110
การแบ่งรหัสและนั่นคือเหตุผลที่ว่าทำไม big-O จึงสำคัญในการเขียนโค้ดที่ปรับขนาดได้นั้นหมายถึงการคิดนอกส่วนเล็ก ๆ

01:12.110 --> 01:14.500
ตรงนี้

01:14.540 --> 01:20.220
มันหมายถึงการคิดถึงการคิดระยะยาวเกี่ยวกับรหัสของคุณและสิ่งที่อาจเกิดขึ้นในอนาคต

01:20.250 --> 01:23.200
ตอนนี้คุณกำลังคิดกับตัวเองตอนนี้

01:23.630 --> 01:28.800
เฮ้อังเดรฉันรู้สึกว่าฉันเพิ่งได้เรียนรู้ทฤษฎีทั้งหมดและไม่มีข้อมูลที่เป็นประโยชน์

01:28.820 --> 01:33.500
อังเดรฉันต้องการทราบอย่างแน่นอนว่าฉันสามารถใช้สิ่งนี้ในชีวิตประจำวันของฉันในฐานะนักเขียนโค๊ดได้อย่างไร

01:33.610 --> 01:35.500
ฉันกำลังเบื่อที่นี่

01:35.720 --> 01:39.710
อะไรที่มีความรู้ที่ค้นพบใหม่นี้คุณจะต้องดูรหัสต่างกัน

01:39.980 --> 01:40.800
ขวา.

01:40.850 --> 01:41.620
มาดูกัน

01:42.780 --> 01:49.970
คุณเห็นตอนนี้เมื่อเราดูวิธีการที่เราได้รับในภาษาเช่นวิธีการในอาร์เรย์

01:50.160 --> 01:56.670
เมื่อพูดถึงจาวาสคริปต์เรามีสิ่งต่าง ๆ เช่น push pop shift on shift

01:56.790 --> 02:03.470
คุณเห็นวิธีการเหล่านี้ทั้งหมดซึ่งฟังก์ชั่นมีค่าใช้จ่ายที่เกี่ยวข้องกับพวกเขา

02:03.540 --> 02:08.530
ค่าใช้จ่ายต่ำมากเช่นเมื่อพูดถึงอาร์เรย์

02:08.540 --> 02:16.710
เมื่อเราค้นหาไอเท็มที่อยู่เหนือฉันเข้าถึงไอเท็มแรกของอาร์เรย์ตัวอย่างมันคือทั้งหมด

02:16.870 --> 02:18.370
แต่เมื่อเราใช้สิ่งที่ชอบ

02:18.370 --> 02:19.620
เมื่อกะ

02:19.930 --> 02:24.620
จริง ๆ แล้วมันกลายเป็นว่าโอ้แล้วทำไมล่ะ

02:24.620 --> 02:30.140
เราจะเข้าสู่เมื่อเราพูดถึงอาร์เรย์โครงสร้างข้อมูลในส่วนโครงสร้างข้อมูล แต่คุณจะเริ่มดูส่วนที่เหลือของหลักสูตรนี้ว่าเราใช้

02:30.800 --> 02:40.530
big-O เพื่อวัดว่าทำไมโครงสร้างข้อมูลหนึ่งอาจดี กว่าคนอื่น ๆ

02:40.550 --> 02:49.920
เหตุใดเราจึงควรใช้อาร์เรย์แทนสมมติว่าวัตถุอาจมีฟังก์ชั่นที่ดีกว่าที่เราต้องการสำหรับข้อมูลที่ยาก

02:51.040 --> 02:58.600
กราฟที่เราได้พูดคุยกันจนถึงตอนนี้จริง ๆ แล้วเป็นส่วนหนึ่งของ Big-O

02:58.600 --> 03:04.290
Chichi dotcom และเลื่อนฟรีที่นี่คุณจะเห็นว่าแต่ละโครงสร้างข้อมูลที่เป็นอาร์เรย์

03:04.350 --> 03:08.180
และในกรณีนี้วัตถุในตารางนี้เป็นตารางแฮช

03:08.340 --> 03:14.010
สิ่งที่เราจะกล่าวถึงในส่วนโครงสร้างข้อมูลอีกครั้ง

03:14.700 --> 03:25.520
แต่เราเห็นว่าเรามีสัญลักษณ์ Big-O ที่แตกต่างกันสำหรับโครงสร้างข้อมูลที่แตกต่างกันและโครงสร้างข้อมูลบางอย่างมีการค้นหาที่ดีมาก ๆ

03:25.530 --> 03:32.190
และคุณสามารถดูได้ที่นี่ว่ามีข้อดีและข้อเสียต่างกันไปตามโครงสร้างข้อมูลเหล่านี้

03:32.970 --> 03:46.800
ดังที่คุณจะพบในโครงสร้างข้อมูลหลักสูตรนี้เป็นเพียงวิธีในการจัดเก็บข้อมูลและอัลกอริทึมเป็นเพียงฟังก์ชั่นหรือวิธีการใช้โครงสร้างข้อมูลเพื่อเขียนโปรแกรมของเรา

03:46.800 --> 04:03.960
จำคำแนะนำของเราสำหรับเครื่องสำหรับคอมพิวเตอร์ของเราและโปรแกรมเมอร์ที่ดีมีความรู้ที่พวกเขาเลือกโครงสร้างข้อมูลที่เหมาะสมอัลกอริทึมที่เหมาะสมในการเขียนโปรแกรมที่ดี

04:04.120 --> 04:26.740
โปรดจำไว้ว่ากฎสองข้อของรหัสที่ดีสามารถอ่านได้และปรับขนาดได้และสิ่งที่เราได้เรียนรู้คือรากฐานสำหรับเราในการตัดสินใจว่าโครงสร้างข้อมูลจะดีที่สุดเมื่อเราเข้าสู่ส่วนโครงสร้างข้อมูลเพราะเราจะรู้ อาเรย์ของช่วยให้เราสามารถเข้าถึงได้ในเวลาคงที่หนึ่ง

04:26.740 --> 04:35.590
แต่เมื่อพูดถึงการค้นหาอาเรย์มันจะให้เวลาเชิงเส้นกับเราบางทีอาจเป็นวัตถุ

04:35.930 --> 04:42.140
ดังนั้นเบื้องหลังแม้ว่าส่วนนี้อาจจะเป็นทฤษฎีและน่าเบื่อเล็กน้อย

04:42.380 --> 04:52.280
สิ่งที่เราเพิ่งเรียนรู้คือการวางรากฐานสำหรับหลักสูตรที่เหลือเพื่อให้เราสามารถเขียนโค้ดที่ดีสำหรับส่วนที่เหลือ

04:52.370 --> 05:03.700
เราจะใช้บิ๊กโอเพื่อดูว่าอะไรคือทางออกที่ดีสำหรับปัญหาและอะไรคือทางออกที่ไม่ดีสำหรับปัญหาในการสัมภาษณ์ส่วนใหญ่มีแนวคิดหลักนี้

05:04.070 --> 05:05.860
โครงสร้างข้อมูลที่ถูกต้องคืออะไร

05:05.930 --> 05:09.650
อัลกอริทึมที่ถูกต้องในการเขียนโปรแกรมที่ดีคืออะไร

05:09.650 --> 05:18.140
Google ว่าจ้างวิศวกรและนักพัฒนาที่รู้เรื่องนี้เพราะพวกเขามีจำนวนมากที่พวกเขาต้องคิด

05:18.260 --> 05:27.760
อินพุตและผู้ใช้จำนวนมากที่รู้วิธีจัดการกับโปรแกรมเหล่านี้เป็นสิ่งที่จะสามารถสร้างโปรแกรมที่ยอดเยี่ยมได้

05:29.360 --> 05:30.790
ฉันจะพบคุณในอีกหนึ่ง

05:30.990 --> 05:31.290
เบบัย
