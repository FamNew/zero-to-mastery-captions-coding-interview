WEBVTT

00:01.500 --> 00:02.360
ยินดีต้อนรับกลับ.

00:02.700 --> 00:07.990
เรามาคุยกันต่อในเรื่องความคิดที่ปรับขนาดได้นี้

00:08.050 --> 00:17.010
คุณจำได้ว่าเราได้พูดคุยเกี่ยวกับห้องครัวและวิธีการคล้ายกับห้องครัวที่เราต้องให้คำแนะนำกับเครื่องของเราในการผลิต

00:17.190 --> 00:20.450
และในวิดีโอก่อนหน้านี้เราได้พูดถึงความผิดปกติในการค้นหา Nemo

00:20.610 --> 00:24.220
มาวัดประสิทธิภาพของฟังก์ชันนี้กัน

00:25.210 --> 00:34.980
จาวาสคริปต์ที่ดีช่วยให้เรามีเครื่องมือเล็ก ๆ ที่ดีที่มาพร้อมกับเบราว์เซอร์ซึ่งเป็นที่ที่เรากำลังเรียกใช้รหัสนี้

00:35.060 --> 00:40.930
ดังนั้นขึ้นอยู่กับภาษาของคุณคุณอาจไม่มีตัวเลือกนี้ แต่คุณจะมีวิธีการวัดที่แตกต่างกัน

00:40.940 --> 00:42.210
อย่าเพิ่งงงกับสิ่งนี้

00:42.230 --> 00:47.460
เราต้องการใช้สิ่งนี้เป็นตัวอย่างในการวัดระยะเวลาที่ใช้ในการเรียกใช้ฟังก์ชันนี้

00:47.540 --> 00:58.940
เราสามารถทำสิ่งนี้ด้วยจาวาสคริปต์โดยสมมติว่าเวลา 0 กำลังจะมีประสิทธิภาพเท่ากันที่มาพร้อมกับเบราว์เซอร์

00:59.340 --> 01:09.590
และเราเพิ่งบอกว่าตอนนี้เพิ่มนี่เข้าไปในศูนย์จะเริ่มจับเวลานี้ก่อนที่ลูปจะเกิดขึ้น

01:09.790 --> 01:19.810
จากนั้นเมื่อลูปสิ้นสุดฉันจะมีตัวจับเวลาอีกตัวชื่อ T-1 และนี่จะเป็นจุดประสิทธิภาพที่เท่ากันตอนนี้

01:20.350 --> 01:34.330
ดังนั้นเราจึงมีสองตัวนับหนึ่งที่จุดเริ่มต้นหนึ่งในตอนท้ายหลังจากฟังก์ชั่นผ่านวนรอบเพื่อค้นหา Nimo และในตอนท้ายเราจะทำบทสนทนาคอนโซลสนุก ๆ

01:34.360 --> 01:49.790
เล็กน้อยและในตอนท้ายเราจะพูดว่า และสามารถทำ Tiran ง่าย ๆ

01:50.480 --> 01:56.800
ลบด้วยศูนย์แล้วเราจะบอกมิลลิวินาทีเพราะมันจะให้ผลลัพธ์กับเราเป็นมิลลิวินาทีเราจะดูว่ามันใช้งานได้ไหม

01:56.900 --> 02:07.080
ฉันต้องการเรียกใช้รหัสนี้และให้ฉันออกจากพื้นที่ในที่นี่และเราเห็นว่ามันใช้เวลาไม่กี่วินาทีในการเรียกใช้รหัสนี้

02:07.190 --> 02:12.770
ขอผมใช้อีกครั้งที่ศูนย์วินาทีอีกครั้งศูนย์วินาทีศูนย์วินาที

02:12.770 --> 02:17.280
และถ้าฉันคลิกมันต่อไปฉันจะเห็นว่าโอ้ตอนนี้ใช้เวลานานขึ้นเล็กน้อย

02:17.480 --> 02:20.200
และนั่นเป็นเพราะมันเร็วจริง ๆ

02:20.210 --> 02:33.990
เครื่องคอมพิวเตอร์นั้นเร็วมากในยุคนี้หรือไม่และเพราะเราแค่วนลูปผ่านสิ่งนี้เพียงครั้งเดียวก็ใช้เวลาเกือบมิลลิวินาทีและจอแสดงผลก็แค่รอบระบบ

02:34.040 --> 02:41.470
แต่ถ้าเรามีอาเรย์ที่ใหญ่กว่าสมมติว่าเรามีอาเรย์ที่นี่ที่มีราคาทุกคนและมันมีตัวละครทั้งหมดหรืออย่างน้อยตัวละครจากภาพยนตร์ Finding Nemo

02:41.630 --> 02:48.100
ซึ่งถ้าคุณยังไม่ได้ดูมัน

02:48.150 --> 02:48.850
ภาพยนตร์ที่น่าตื่นตาตื่นใจ

02:48.860 --> 02:50.510
ขอแนะนำอย่างยิ่ง

02:50.520 --> 02:54.640
อย่างไรก็ตามเราเห็นว่าเรามีตัวละครมากขึ้นในตอนนี้

02:54.710 --> 03:15.760
ดังนั้นแทนที่จะมีอาเรย์เดี่ยวเรามาสร้างอาเรย์ทุกคนที่นี่และตอนนี้อาเรย์มีไอเท็มอีกมากมายมีหนึ่งสองสามสี่ห้าหกเจ็ดแปดเก้าสิบสิบนั่นคือสิบลูปที่นี่ที่เราจะทำถ้าเราวิ่ง นี้.

03:16.040 --> 03:19.200
เราเห็นว่าเวลายังคงเหมือนเดิม

03:19.370 --> 03:21.290
ค่อนข้างศูนย์วินาที

03:21.410 --> 03:25.210
บางครั้งก็เพิ่มขึ้นเล็กน้อยและเวลาเปลี่ยนแปลงตลอดเวลา

03:26.260 --> 03:29.590
แต่เราไม่เห็นความแตกต่างที่เราทำ

03:29.590 --> 03:35.970
ฉันหมายความว่าเราวิ่งจากลูปหนึ่งไปยัง 10 ลูป แต่ก็ยังเร็วสุดเร็ว

03:36.040 --> 03:40.150
และอีกครั้งนั่นเป็นเพราะคอมพิวเตอร์ของเราในยุคนี้ค่อนข้างเร็ว

03:40.150 --> 03:44.590
ความแตกต่างระหว่างลูปหนึ่งกับ 10 ลูปนั้นไม่ใหญ่มาก

03:45.560 --> 03:51.720
แต่ลองทำเคล็ดลับความสนุกเล็กน้อยที่นี่ใน javascript เราสามารถสร้างอาร์เรย์ขนาดใหญ่

03:51.760 --> 03:59.520
ลองเรียกมันว่าใหญ่และเราสามารถสร้างอาร์เรย์ขนาดใหญ่โดยเพียงแค่บอกว่าอาร์เรย์ใหม่

04:00.520 --> 04:08.800
และเราจะให้มันเป็นร้อยรายการและร้อยรายการนี้ในอาร์เรย์ที่เราสามารถเติมมันด้วยสมมุติว่า Nimo และนี่เป็นเพียงการสร้างอาร์เรย์ที่มี

04:08.800 --> 04:15.540
Nimo ร้อยครั้งดังนั้นแทนที่จะเป็นก้อนหินขนาดใหญ่ทุกก้อน

04:19.190 --> 04:30.200
เราเห็นที่นี่ว่าพบ Nimo ร้อยครั้งเพราะเราเพิ่งเติม Nimo

04:30.200 --> 04:38.720
ด้วยและที่ด้านล่างเราเห็นว่ามันใช้เวลาห้า Moli วินาทีซึ่งใช้เวลานานกว่ามาก

04:38.730 --> 04:41.640
Dinant มาช่วยกันใหญ่กว่ากันเถอะ

04:41.670 --> 04:47.150
ลองทำหนึ่งพันนัดกับรอนใช้เวลา 7 มิลลิวินาที

04:47.150 --> 04:49.740
ทีนี้ถ้าคุณทำมันให้ใหญ่กว่านี้ล่ะ

04:49.740 --> 04:52.110
เกิดอะไรขึ้นถ้าเรามีจำนวนมหาศาล 10,000

04:52.410 --> 04:55.990
เราวิ่ง 46 เมลีวินาที

04:56.010 --> 04:57.480
มันยังค่อนข้างเร็ว

04:57.480 --> 04:59.340
และเพื่อความสนุกสนานอีกครั้ง

04:59.340 --> 05:14.230
ถ้าฉันวิ่งคุณเห็นความล่าช้านั้นและเวลาที่ใช้เวลานั้นใช้เวลาสี่สิบสามมิลลิวินาทีหรือสามจุดสี่วินาทีตอนนี้เราจะเห็นอะไร

05:14.230 --> 05:24.220
เราเห็นว่าเมื่ออินพุตของเราเพิ่มฟังก์ชันของเราพบว่า Nemo ช้าลงและช้าลงและช้าลง

05:24.280 --> 05:30.430
เวลาทำงานของเราใช้เวลานานแค่ไหนในการรันปัญหาบางอย่างผ่านฟังก์ชันที่เพิ่มขึ้น

05:30.490 --> 05:32.830
แต่นี่คือปัญหาที่นี่

05:32.830 --> 05:40.030
หากคุณใช้รหัสนี้และเรียกใช้บนคอมพิวเตอร์ของคุณในขณะที่เวลาของคุณจะแตกต่างจากของฉัน

05:40.570 --> 05:44.140
และฉันจะปล่อยโค้ดนี้ไว้ท้ายวิดีโอนี้เพื่อให้คุณสามารถเล่นกับมันได้

05:44.290 --> 05:50.860
คุณจะหงุดหงิดเพราะทุกครั้งที่คุณใช้รหัสนี้จะแตกต่างจากหมายเลขของฉัน

05:51.190 --> 05:53.910
มันอาจจะเร็วกว่าเยอะกว่ามาก

05:53.950 --> 06:00.040
คุณเห็นสิ่งนี้ทั้งหมดขึ้นอยู่กับประสิทธิภาพของ C พี

06:00.370 --> 06:06.660
คุณในคอมพิวเตอร์คืออะไรและโปรแกรมอื่นกำลังทำงานกับภาษาการเขียนโปรแกรมคอมพิวเตอร์ที่คุณใช้อยู่

06:06.670 --> 06:11.370
ดังนั้นจึงมีปัจจัยเหล่านี้ทั้งหมดที่เล่นที่นี่ในรันไทม์ของเรา

06:11.410 --> 06:17.110
ดังนั้นถ้าฉันเร่งความเร็วเพื่อนของฉันทั่วโลกลองเรียกพวกเขาว่าจอห์นนี่และฉันจะบอกเขาว่าเฮ้จอห์นนี่รหัสของฉันนั้นยอดเยี่ยมมากฉันได้สร้างฟังก์ชั่น Nimo

06:17.110 --> 06:27.820
ที่ดีขึ้น 2 วินาทีพร้อมอินพุตนับแสน

06:27.820 --> 06:29.750
วิธีการที่ดีของไตรมาสฉัน

06:29.800 --> 06:32.460
แล้วจอห์นนี่บอกว่าฮาช่างน่าทึ่งจริงๆ

06:32.470 --> 06:33.610
แต่คุณรู้อะไรไหม.

06:33.670 --> 06:36.670
ฉันวิ่งเร็วกว่ามากใน 1 5 วินาที

06:36.730 --> 06:37.990
ดังนั้นฉันไป

06:38.290 --> 06:40.610
คุณคิดว่าอะไรที่คุณคิดว่าจอห์นนี่ชนะ

06:41.450 --> 06:44.510
จอห์นนี่มีรหัสที่ดีกว่าฉันหรือเปล่า

06:45.590 --> 06:47.450
นี่คือสิ่งที่

06:47.630 --> 06:49.230
ไม่จำเป็น.

06:49.420 --> 06:51.340
มันไม่ได้มีความหมายอะไรมากนัก

06:52.190 --> 06:56.330
เพราะมันเป็นสิ่งสำคัญคอมพิวเตอร์ประเภทจอห์นนี่มีปัจจัยอื่นอะไร

06:56.360 --> 07:00.410
ตามที่ฉันพูดถึงก่อนที่โค้ดจะทำงาน

07:00.490 --> 07:02.470
ดังนั้นเราจะตัดสินได้อย่างไรว่าใครจะชนะ

07:02.530 --> 07:04.280
ฉันจะชนะหรือไม่ชนะจอห์นนี่

07:04.330 --> 07:06.230
ใครมีโค้ชที่ดีกว่า

07:06.290 --> 07:09.500
และนี่เป็นเรื่องธรรมดามากในโลกคอมพิวเตอร์

07:09.670 --> 07:16.030
เราเขียนโค้ดบนแล็ปท็อปคอมพิวเตอร์ของเรา แต่รหัสนั้นไม่จำเป็นต้องทำงานบนอุปกรณ์เหล่านั้น

07:16.300 --> 07:24.160
หากเรามีบางอย่างเช่นเซิร์ฟเวอร์เราอาจให้รหัสนั้นทำงานที่อื่นในคอมพิวเตอร์เครื่องอื่นทั่วโลก

07:24.160 --> 07:41.260
ดังนั้นเราจะมั่นใจได้อย่างไรว่ามีวิธีที่เราจะวัดประสิทธิภาพได้ว่ารหัสที่ดีและอะไรคือรหัสที่ไม่ดีและรหัสที่สามารถปรับขนาดได้เมื่อจำนวนอาร์เรย์หรืออินพุตเพิ่มขึ้น

07:41.260 --> 07:48.790
มันไม่ได้ทำให้เครื่องหมาย Big-O ช้าลงมากขึ้นเรื่อย ๆ

07:48.790 --> 07:51.590
เป็นภาษาที่เราใช้พูดถึงระยะเวลาที่อัลกอริทึมใช้

07:51.940 --> 08:00.190
เราสามารถเปรียบเทียบอัลกอริธึมที่แตกต่างกันสองแบบหรือในกรณีนี้ใช้ฟังก์ชั่นใหญ่ -O

08:00.190 --> 08:05.060
และบอกว่าอันไหนดีกว่าอีกอย่างเมื่อเทียบกันโดยไม่คำนึงถึงความแตกต่างของคอมพิวเตอร์ของเรา

08:05.410 --> 08:09.650
และเราสามารถวัดการแสดงที่ยิ่งใหญ่เช่นนี้

08:09.760 --> 08:13.780
ฉันจะเตือนคุณว่านี่จะดูสับสนในตอนแรก

08:13.870 --> 08:16.400
และนี่เป็นครั้งแรกที่เราเห็นแผนภาพนี้

08:16.720 --> 08:22.710
และไม่ต้องกังวลในตอนท้ายของส่วนนี้สิ่งนี้จะสมเหตุสมผล

08:22.720 --> 08:24.280
ดังนั้นเชื่อใจฉันและสิ่งนี้

08:24.310 --> 08:25.540
ติดตามวิดีโอเหล่านี้ต่อไป

08:25.540 --> 08:31.630
ฉันรู้ว่าฉันกำลังวนเวียนอยู่รอบ ๆ หัวข้อและไม่ได้ถูกชี้นำว่ามันหมายถึงอะไร

08:31.630 --> 08:36.040
แต่ฉันสัญญากับคุณในตอนท้ายว่าสิ่งนี้จะสมเหตุสมผลและคุณจะเป็นนินจาตัวใหญ่

08:37.460 --> 08:44.480
เมื่อเราพูดถึง big-O และ

08:44.480 --> 08:49.470
scalability ของรหัสเราก็หมายถึงเมื่อเราโตขึ้นและใหญ่ขึ้นด้วยการป้อนข้อมูลของเราอัลกอริทึมหรือฟังก์ชั่นช้าลง

08:50.430 --> 08:57.720
ถ้ารายชื่อตัวละครสมมุติว่าองค์ประกอบที่นี่คือ Nimo

08:57.720 --> 09:05.870
ดังนั้นตัวละครในการค้นหา nemo ในอาเรย์ของเรานั้นจะเพิ่มจำนวนการดำเนินการที่ต้องทำอีกมาก

09:05.930 --> 09:07.960
นั่นคือทั้งหมดที่มันเป็น

09:08.020 --> 09:15.400
นี่คือสิ่งที่เราเรียกว่าประสิทธิภาพอัลกอริทึมใหญ่ -O ช่วยให้เราสามารถอธิบายแนวคิดนี้

09:15.420 --> 09:21.690
จำได้ไหมว่าในการทำงานของเราในตอนแรกเรามีอาร์เรย์ของอันที่เป็นนิโม

09:21.750 --> 09:23.550
นั่นคือจำนวนองค์ประกอบ

09:23.550 --> 09:26.190
จำนวนอินพุตในฟังก์ชัน

09:26.460 --> 09:27.320
มันอยู่ตรงนี้

09:27.420 --> 09:34.780
แต่เมื่อเราเพิ่มอาเรย์นั้นเพื่อให้มีตัวละครมากขึ้นจากนั้นเราก็สร้างอาเรย์ที่มีขนาดใหญ่จำนวน 100,000

09:34.830 --> 09:41.490
ดังนั้นเมื่อเพิ่มขึ้นคุณจะเห็นว่าจำนวนของการดำเนินการหรือจำนวนสิ่งที่เราทำในลูปเพิ่มขึ้นเรื่อย ๆ

09:41.970 --> 09:49.020
และฟังก์ชั่นที่แตกต่างกันมีความซับซ้อนของ O ขนาดใหญ่ต่างกัน

09:49.020 --> 09:55.810
นั่นคือจำนวนการดำเนินการเหล่านี้สามารถเพิ่มขึ้นอย่างรวดเร็วจริงๆเช่นนี้ซึ่งไม่ดี

09:55.810 --> 10:02.770
คุณจะเห็นว่ามันน่ากลัวและสิ่งต่าง ๆ ที่ค่อนข้างดีและไม่เพิ่มขึ้นมาก

10:02.880 --> 10:15.950
และเราจะดูตัวอย่างของสิ่งที่แตกต่างกันและวิธีการวัดสิ่งนี้และความหมายของสัญกรณ์ทั้งหมดนี้ แต่จบวิดีโอนี้เพื่อให้เราสามารถดำน้ำลึกลงไปในหัวข้อ

10:16.020 --> 10:23.190
เพียงแค่จำจุดนี้เมื่อเราพูดถึง

10:23.190 --> 10:35.880
Big O และความสามารถในการขยายของโค้ดเราหมายถึงเมื่อเราโตขึ้นและใหญ่ขึ้นด้วยอินพุตของเราอัลกอริทึมช้าลงยิ่งน้อยลงช้าลงหรือช้าลงก็ยิ่งดีขึ้น

10:36.760 --> 10:53.600
ดังนั้นแทนที่จะใช้ประสิทธิภาพที่ทำในตอนนี้และใช้เวลาในการวัดประสิทธิภาพของฟังก์ชั่นของเราเราสามารถคำนวณจำนวนการทำงานของคอมพิวเตอร์ได้เนื่องจากการดำเนินการแต่ละครั้งต้องใช้เวลาบนคอมพิวเตอร์

10:53.950 --> 11:02.020
การแสดงที่ยิ่งใหญ่ครั้งนี้ทำให้เราและกังวลกับเราว่ามีกี่ขั้นตอนในการทำงาน

11:02.020 --> 11:05.680
เอาล่ะขุดลึกลงไปในหัวข้อนี้

11:05.770 --> 11:07.450
ฉันจะดูในวิดีโอหน้า Bebai
