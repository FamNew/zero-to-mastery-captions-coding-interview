WEBVTT

00:03.250 --> 00:12.380
ฉันต้องการแสดงให้คุณเห็นหนึ่งตัวอย่างสุดท้ายและนี่อาจเป็นตัวอย่างที่ดีที่สุดว่าทำไมการเขียนโปรแกรมแบบไดนามิกจึงสำคัญ

00:12.730 --> 00:17.540
และอย่างที่คุณจะจำได้เมื่อฉันพูดถึงการเขียนโปรแกรมแบบไดนามิกซึ่งฟังดูสับสน

00:17.650 --> 00:23.900
แค่คิดว่าการแคชเพิ่มประสิทธิภาพบางอย่างโดยใช้แคช

00:23.920 --> 00:31.820
หนึ่งในตัวอย่างที่ดีที่สุดว่าทำไมการเขียนโปรแกรมแบบไดนามิกจึงดีคือลำดับฟีโบนักชีเพื่อนเก่าที่ดีของเรา

00:32.320 --> 00:39.150
เราเรียนรู้เกี่ยวกับสิ่งนี้ในส่วนการสอบถามซ้ำของเราซึ่งตัวเลขสองตัวก่อนหน้ารวมกันเป็นหมายเลขถัดไป

00:39.640 --> 00:48.160
ดังนั้น 13 คือห้าบวกแปดสิบสี่คือ 13 บวก 21 และมันยังคงเติบโตต่อไปเรื่อย

00:48.760 --> 00:51.750
ๆ และเราเรียนรู้วิธีคำนวณสิทธิ์

00:51.820 --> 00:56.170
เราสามารถคำนวณจำนวนฟีโบนักชีได้อย่างง่ายดาย

00:56.170 --> 01:03.310
เรามีฟังก์ชั่นฟีโบนักชีซึ่งเป็นชื่อที่สะกดยาก

01:03.430 --> 01:12.770
ฉันเชื่อว่ามันเป็นอย่างนี้และสิ่งที่เราทำก็คือเราบอกว่าใช้การเรียกซ้ำเรามีกรณีพื้นฐานคือน้อยกว่าสอง

01:12.780 --> 01:18.210
ในกรณีนั้นเราจะคืนค่าเป็นอย่างอื่น

01:18.250 --> 01:31.050
เราทำการสอบถามซ้ำแบบสนุก ๆ เราส่งคืนฟีโบนักชีและลบหนึ่งบวกฟีโบนัชชีและลบสอง

01:31.340 --> 01:41.460
ดังนั้นถ้าฉันต้องการหาหมายเลขฟีโบนักชีที่ดัชนีของสมมติว่า 6 และฉันเรียกใช้นี้

01:41.560 --> 01:44.950
และบันทึกควรจะเป็นจำนวน

01:44.950 --> 01:45.990
เรียกใช้อีกครั้ง

01:46.240 --> 01:53.830
ฉันได้ 8 เพราะ 0 1 2 3 4 5 6 8 5 2 7

01:53.830 --> 01:57.640
ฉันควรได้ 13 อันยอดเยี่ยม

01:57.650 --> 01:59.830
นี่คือสิ่งที่เราควรทำความคุ้นเคย

02:00.060 --> 02:01.600
แต่ให้ฉันถามคำถามคุณ

02:01.640 --> 02:04.550
ฟังก์ชั่นนี้มีประสิทธิภาพเพียงใด

02:05.930 --> 02:07.810
และเราได้พูดคุยเกี่ยวกับมันก่อนที่จะถูก

02:07.820 --> 02:09.150
มันไม่ได้มีประสิทธิภาพมาก

02:09.260 --> 02:17.200
ถ้าฉันมีตัวแปรตรงนี้ที่บอกว่าลองเรียกมันว่าการคำนวณซึ่งจะเท่ากับศูนย์

02:17.380 --> 02:24.130
และเราจะเพิ่มค่านี้ทุกครั้งที่ฟังก์ชันนี้ถูกเรียก

02:24.340 --> 02:27.940
และเพราะมันเกิดซ้ำเรารู้ว่ามันถูกเรียกหลายครั้ง

02:28.210 --> 02:31.900
ถ้าฉันทำฟีโบนักชี 7 คำนวณได้เท่าไหร่

02:31.960 --> 02:38.710
นั่นคือการคำนวณ 13 ครั้งดังนั้น 13 ครั้งที่เราวิ่งผ่านฟังก์ชัน Bonacci ฟรี

02:38.710 --> 02:45.840
ถ้าฉันเพิ่มมันเป็น 8 21 โอเคจะเป็นอะไรประมาณเก้าสามสิบสี่

02:45.870 --> 02:48.710
อะไรประมาณ 10 ห้าสิบห้า

02:48.710 --> 02:50.690
เอาล่ะมันเพิ่มขึ้นอย่างรวดเร็ว

02:50.690 --> 02:52.720
ถ้าฉันทำ 12

02:52.780 --> 02:57.640
การคำนวณหนึ่งร้อยสี่สิบสี่เพียงเพื่อให้ได้ดัชนีที่ 12

02:57.640 --> 03:04.710
ว้าวจะเป็นอย่างไรถ้าฉันคำนวณ 15 610 ครั้ง

03:05.010 --> 03:07.530
ประมาณ 20

03:07.700 --> 03:09.200
moly ศักดิ์สิทธิ์

03:09.200 --> 03:13.180
การคำนวณมากกว่า 6,000 รายการและเพื่อความสนุกสนาน

03:13.190 --> 03:16.050
ถ้าฉันทำ 25 โอวอย

03:16.120 --> 03:18.040
ครั้งสุดท้ายใช่ไหมเพราะเราสนุก

03:18.040 --> 03:19.730
30

03:19.810 --> 03:20.200
เอาล่ะ

03:20.200 --> 03:21.900
นั่นคือการคำนวณจำนวนมาก

03:22.180 --> 03:28.760
และโดยวิธีถ้าคุณชนะเบราว์เซอร์ของคุณผิดพลาดเพียงพิมพ์ 50 หรือ 60 และดูว่าเกิดอะไรขึ้น

03:30.160 --> 03:39.250
ไม่ว่าเราจะดูที่ผนังนี้มันช่างน่ากลัวเพียงแค่คำนวณหมายเลข 30

03:39.250 --> 03:45.910
หรือดัชนีของลำดับฟีโบนักชีทำตามขั้นตอนหลายขั้นตอนที่การคำนวณจำนวนมาก

03:45.910 --> 03:47.680
ที่เป็นจำนวนมาก.

03:47.680 --> 03:49.230
มันไม่ได้มีประสิทธิภาพมาก

03:49.490 --> 03:57.220
และเรารู้ว่าถูกต้องเพราะในส่วนการสอบถามซ้ำเราพูดถึงว่าลำดับฟีโบนักชีและวิธีที่เราใช้งานฟังก์ชันคือ 0 จาก

03:57.250 --> 04:04.480
2 ถึงพลังของและความซับซ้อนของเวลาที่เลวร้ายจริงๆ

04:05.580 --> 04:10.350
ของขั้นตอน

04:10.440 --> 04:26.400
และจำไว้ว่าเมื่อเรียกซ้ำเราจะเพิ่มการเรียกใช้ฟังก์ชันที่ซ้อนกันทุกครั้งเพิ่มลงในสแต็กซึ่งเพิ่มความซับซ้อนของหน่วยความจำของเราและเราจะไม่ต้องการดำเนินการที่มีค่าใช้จ่ายในชีวิตจริง

04:26.430 --> 04:28.930
ดังนั้นเราจะทำให้มีประสิทธิภาพมากขึ้นได้อย่างไร

04:29.100 --> 04:31.530
เราสามารถทำให้มีประสิทธิภาพมากขึ้น

04:31.530 --> 04:38.790
ฉันหมายถึงว่าหน้าที่ของเราถ้าคุณเขียนฟังก์ชันนั้นเป็นหัวหน้าของคุณจะไล่คุณออกไปเพราะมันน่ากลัว

04:38.910 --> 04:54.300
ฉันหมายถึงว่าเจ้านายของคุณน่ากลัวบางที แต่ถ้าคุณรู้ว่าการเขียนโปรแกรมแบบไดนามิกคุณสามารถหลีกเลี่ยงสิ่งนี้ได้เพราะถ้าฉันบอกคุณว่าเราสามารถทำได้และด้วยฟังก์ชั่นนี้เพราะด้วยการเขียนโปรแกรมแบบไดนามิกที่เราทำได้

04:54.600 --> 05:01.320
ถูกต้องที่เราสามารถไปจากทั้งสองไปที่สวนสาธารณะและลงไปจนถึงพวกเขาทั้งหมด

05:01.590 --> 05:03.900
ฟังดูเหมือนเวทมนต์ไม่ได้

05:03.900 --> 05:07.370
และนี่คือที่เราไปถึงขั้นตอนต่อไปของการเขียนโปรแกรมแบบไดนามิกของเรา

05:07.440 --> 05:20.470
เราสามารถลดเวลาและพื้นที่ที่ซับซ้อนของอัลกอริทึมของเราโดยใช้การท่องจำและเราสามารถทำได้เพราะการแก้ปัญหาของแต่ละปัญหาคือสิ่งที่เราเรียกว่าดีที่สุด

05:20.470 --> 05:26.560
นั่นหมายความว่าเราทำปัญหามากมายซ้ำ ๆ กันซึ่งเหมือนกันในวิดีโอถัดไป

05:26.560 --> 05:30.290
เราจะอธิบายแนวคิดนี้และดูว่าเราสามารถใช้บันทึกช่วยจำได้อย่างไร

05:30.650 --> 05:31.300
ฉันจะเห็นสิ่งนั้น
