WEBVTT

00:01.300 --> 00:02.410
ยินดีต้อนรับกลับ.

00:02.800 --> 00:09.370
สมองของคุณออกกำลังกายอย่างไรที่ได้ยินจากลำดับที่สับสนทั้งหมดนี้

00:09.370 --> 00:20.850
ลองเริ่มจากฟังก์ชั่นวนซ้ำในคราวนี้เพราะในกรณีนี้ฟังก์ชั่นวนซ้ำนั้นง่ายกว่าที่คิด

00:21.930 --> 00:35.270
สิ่งที่เราจะทำกับฟังก์ชั่นวนซ้ำคือบอกว่ากรณีฐานจะบอกว่าเลขสี่และจะเท่ากับสอง

00:35.470 --> 00:49.100
หากเป็นกรณีนี้ก็จะกลับมาจริงถ้าเราดูลำดับเราจะเห็นว่าถ้าพวกมันทำดัชนีศูนย์

00:49.160 --> 00:53.900
หากดัชนีคือ 1 คำตอบคือ 1

00:54.200 --> 00:58.690
และถ้าดัชนีเป็น 2 คำตอบจะเปลี่ยนเป็น 1

00:58.700 --> 01:04.260
ดังนั้นแทนที่จะเป็นกรณีฐานของเราอาจจะเพียงแค่ถ้า a น้อยกว่า 2

01:04.280 --> 01:08.280
เรามักจะหันไปไม่ว่าจุดจบจะเป็นอย่างไร

01:08.300 --> 01:13.500
ถ้าเราบอกว่า 0 มันจะกลับเป็น 0 ถ้าเราบอกว่าหนึ่งจะกลับ 1

01:13.580 --> 01:22.150
หากเรามีดัชนีที่สูงกว่านั้นเราต้องทำการวนรอบซ้ำและสิ่งที่เราจะทำที่นี่คือตอนนี้มีคำสั่ง return

01:22.150 --> 01:27.730
และพูดฟังก์ชัน

01:27.730 --> 01:30.270
ฉันรู้ว่าฟังก์ชั่นนี้ยาวจริงๆ

01:30.280 --> 01:33.630
เราอาจทำให้สั้นลงได้เพียงแค่พูดปด

01:33.730 --> 01:38.140
และฉันสังเกตเห็นว่าเราไม่จำเป็นต้องทำซ้ำที่นี่

01:38.300 --> 01:39.900
ที่จะทำให้มันสั้นลงเล็กน้อย

01:39.900 --> 02:01.180
ใช่แล้วเรารู้ว่าเราจะบอกว่าเฟดจะเท่ากันและลบหนึ่งบวกด้วยสิ่งเดียวกันลบสองเพราะจำได้เสมอ

02:01.180 --> 02:07.450
คำตอบคือหมายเลข 1 และ 2 ก่อนเสมอ

02:07.560 --> 02:17.560
ดังนั้นเราแค่เพิ่มตัวเลข 1 และ 2 ก่อนลำดับของเราและนั่นคือมัน

02:17.560 --> 02:26.230
ถ้าเราเรียกใช้ฟังก์ชันนี้สมมุติว่าเรามี Bonacci แบบเรียกซ้ำ 3 และฉันคลิก run ฉันจะได้ 2 เพราะ 0

02:26.470 --> 02:36.180
1 2 3 คือ 2 ลองทำ 8 ซึ่งควรให้ 21 กับเราและคลิก Run หรือให้ 8

02:36.290 --> 02:45.930
ฉันได้ 21 ดีและถ้าฉัน 0 ฉันได้ 0

02:46.290 --> 02:49.050
ถ้าฉันทำอย่างใดอย่างหนึ่งฉันได้รับหนึ่ง

02:49.080 --> 02:53.470
ถ้าฉันทำฉันก็ควรจะได้อันนี้

02:53.520 --> 02:58.530
ดีและเรียบง่ายดีฉันไม่รู้เกี่ยวกับความเรียบง่าย

02:58.570 --> 03:04.340
คุณต้องคุ้นเคยกับสิ่งนี้ก่อนที่คุณจะเข้าใจสิ่งที่เกิดขึ้นจริง

03:04.420 --> 03:06.630
แต่ฉันมีแผนภาพเล็ก ๆ เพื่อช่วยคุณที่นี่

03:07.570 --> 03:10.300
สิ่งที่เราทำก็แค่นี้

03:10.450 --> 03:19.900
ถ้าผมบวก 7 ตรงนี้ฟังก์ชันการเรียกซ้ำจะได้หนึ่งน้อยกว่า 7 และ 2

03:19.930 --> 03:26.080
น้อยกว่า 5 แล้วภายในฟังก์ชันเหล่านั้นทำแบบเดียวกันหนึ่งน้อยกว่าหกถึงน้อย

03:26.170 --> 03:30.090
ต้องการส่ง 5 ให้น้อยกว่า 3 และทำสิ่งเหล่านี้ทั้งหมด

03:30.100 --> 03:39.420
ทั้งหมดเหล่านี้ทั้งหมดจนกว่าเราจะได้ FEBE เท่ากับ 1 ซึ่งเรามีกรณีพื้นฐานของเราที่ส่งคืนตัวเลขนั้น

03:39.500 --> 03:42.310
ดังนั้นนี่จึงกลายเป็นหนึ่ง

03:42.430 --> 03:49.170
สิ่งนี้ก็กลายเป็นหนึ่งแล้วมันก็เดินต่อไปเรื่อย ๆ เรื่อย ๆ จนกว่าเราจะถึง FEBE ที่ 7

03:49.180 --> 03:54.340
ทีนี้นี่คือแผนภาพที่เราจะกลับไป แต่คุณเห็นว่าเราทำการคำนวณมากมายที่นี่

03:55.250 --> 03:57.770
แต่เพียงแค่ใส่นี่คือทั้งหมดที่เรากำลังทำ

03:59.820 --> 04:06.360
ตอนนี้ฉันบอกว่าวิธีแบบเรียกซ้ำเป็นจริงง่ายกว่าวิธีแบบวนซ้ำ

04:06.810 --> 04:10.860
ลองมาดูกันว่ารูปแบบการวนซ้ำจะเป็นอย่างไร

04:10.950 --> 04:14.790
เราจะสร้างอาร์เรย์และมีหลายวิธีในการทำเช่นนี้

04:14.790 --> 04:24.370
นี่คือวิธีที่ฉันชอบและแบบสำรวจนี้จะมีรายการเริ่มต้นของลำดับ 0 และ 1

04:24.580 --> 04:31.280
และนี่คือก่อนอื่นเลยส่งคืนอาร์เรย์ของรายการ

04:31.280 --> 04:36.680
และเรากำลังสร้างอาเรย์นี้แล้วจับดัชนีอะไรก็ได้ที่ผู้ใช้ต้องการ

04:36.680 --> 04:43.940
ในกรณีของเราหากผู้ใช้ร้องขอ 0 หรือ 1 เรามีอาร์เรย์ที่เติมข้อมูลด้วยศูนย์และ 1

04:43.940 --> 04:45.390
แล้วและมันจะกลับมาเหมือนเดิม

04:45.800 --> 04:49.610
แต่เรายังต้องคำนวณหาอีกอัน

04:49.610 --> 04:58.760
นั่นคือสิ่งที่เราทำเพื่อวนรอบและบอกให้ฉันเท่ากับสองเพราะเราจะเริ่มเพิ่มเมื่อดัชนีเป็น 0 1

04:59.000 --> 05:12.560
2 เพื่อเริ่มเติมการสำรวจจะบอกว่าน้อยกว่าบวกหนึ่ง เราจะปล่อยไว้ที่ตอนนี้และเราจะเพิ่ม i

05:12.560 --> 05:17.660
บวกบวก

05:17.960 --> 05:26.390
และในวงนี้เราจะดำเนินต่อไปจนกว่าเราจะไปถึงจำนวนดัชนีที่เราสนใจและทั้งหมดที่เราจะพูดคือ

05:28.980 --> 05:38.890
push array ฉันลบสองบวกอีกครั้ง

05:39.110 --> 05:40.640
คล้ายกับสิ่งที่เราทำมาก่อน

05:40.640 --> 05:45.830
เราแค่หาผลรวมของตัวเลขสองตัวก่อนหน้าและกดไปที่อาร์เรย์

05:46.820 --> 05:47.320
เอาล่ะ

05:47.420 --> 05:49.030
ทีนี้มาดูกันว่ามันใช้งานได้ไหม

05:49.070 --> 05:53.410
ฉันจะแสดงความคิดเห็นออกมาและทำวิธีการวนซ้ำ

05:54.630 --> 05:56.760
ฉันได้รับสองถึงสาม

05:56.760 --> 05:58.900
สิ่งที่เกี่ยวกับดัชนีแปด

05:59.070 --> 06:01.740
ฉันได้ 21 ที่สมบูรณ์แบบ

06:01.830 --> 06:11.640
แล้วถ้าฉันทำดัชนี 0 และ X ของ 1 และดัชนีสองควรจะสมบูรณ์

06:11.670 --> 06:16.980
ตอนนี้ฉันบอกว่าวิธีแบบเรียกซ้ำนั้นง่ายกว่าวิธีแบบวนซ้ำ

06:16.980 --> 06:18.880
ตอนนี้นั่นเป็นความเห็นส่วนตัวของฉัน

06:18.930 --> 06:28.090
คุณอาจไม่คิดว่าคุณอาจคิดว่านี่เป็นเรื่องง่าย แต่สำหรับฉันแล้วมันอ่านได้ดีกว่าสิ่งที่เราทำ

06:28.960 --> 06:44.210
และนี่คือสิ่งที่เรากำลังจะได้รับในวิดีโอหน้าที่เราพูดถึงการแลกเปลี่ยนระหว่างการวนซ้ำและการวนซ้ำของปัญหาเหล่านี้และทำไมบางทีคุณอาจสงสัยว่าตอนนี้ทำไมเราจะเขียนอะไรซ้ำ

06:44.380 --> 06:48.720
หากคุณพบว่าสิ่งนี้ทำให้เราสับสน

06:48.810 --> 06:54.000
แต่สิ่งหนึ่งที่ฉันต้องการแสดงให้คุณเห็นคือสิ่งที่เราเพิ่งเรียนรู้ที่นี่ซึ่งเป็นเรื่องใหม่สำหรับเรา

06:54.540 --> 06:57.370
คุณคิดว่าฟังก์ชั่นใหญ่ของทั้งสองนี้คืออะไร

06:59.030 --> 07:02.770
ในโซลูชันวนซ้ำของเรา

07:02.870 --> 07:06.410
O ตัวใหญ่คือเวลาเชิงเส้นตรง

07:06.410 --> 07:07.640
มันเป็นของ

07:07.670 --> 07:20.490
โดยพื้นฐานแล้วเราแค่วนซ้ำวนซ้ำและลบสองครั้งเพราะเราข้ามสองรายการแรกซึ่งจะทำให้เกิดขึ้น

07:20.560 --> 07:22.110
เตาอบ

07:22.150 --> 07:25.930
แต่สิ่งที่เกี่ยวกับวิธีแบบเรียกซ้ำ

07:25.960 --> 07:28.610
จำแผนภาพที่ฉันแสดงให้คุณเห็น

07:28.860 --> 07:34.860
นั่นคือการคำนวณที่มากขึ้นกว่าแค่เจ็ดอัตรา

07:34.970 --> 07:42.430
เรามีการเรียกใช้ฟังก์ชันจำนวนมากที่เกิดขึ้นในกรณีนี้ในโซลูชันการเรียกซ้ำ

07:42.430 --> 08:06.120
มันต้องใช้สิ่งที่เราเรียกว่าเวลาเอ็กซ์โพเนนเชียลขนาดของต้นไม้จะเพิ่มขึ้นอย่างทวีคูณเมื่อใดและเพิ่มขึ้นถ้าจำนวนฟีโบนักชีเท่ากับแปดเราจะได้ต้นไม้นี้

08:08.140 --> 08:13.040
นี่เป็นเรื่องที่น่าตื่นเต้นมากเพราะเรากำลังเรียนรู้เกี่ยวกับสัญลักษณ์ Big O ใหม่

08:13.270 --> 08:17.520
เรากำลังเรียนรู้เกี่ยวกับเวลาหนึ่งแทน

08:18.670 --> 08:28.080
ซึ่งสามารถมองเห็นได้ด้วยอัลกอริทึมแบบเรียกซ้ำที่แก้ปัญหาขนาดและ 2 กับกำลังของถ้าเราไปที่ O Chichi ใหญ่ของเรานี่คือ

08:28.080 --> 08:33.230
0 2 ต่อพลังของมด

08:33.270 --> 08:37.860
และคุณเห็นว่ามันเพิ่มขึ้นเท่าใด

08:37.860 --> 08:39.520
มันค่อนข้างแย่

08:39.780 --> 08:52.860
มันมีขนาดใหญ่กว่า 0 และสี่เหลี่ยมทั้งสองซ้อนกันเป็นเวลาลูป exponential หมายความว่าทุกองค์ประกอบเพิ่มเติมในลำดับฟีโบนักชี

08:52.880 --> 08:58.070
เราได้รับการเพิ่มฟังก์ชั่นการโทรชี้แจง

08:58.150 --> 09:05.410
และนี่คือเคล็ดลับเล็ก ๆ น้อย ๆ ที่สนุกสนานแม้ว่านี่จะเป็นวิธีที่วนซ้ำทั้งหมด

09:05.410 --> 09:18.660
ฟังก์ชั่นนี้เพราะมันเป็นสองเท่าของกำลังถ้าผมเรียกใช้ฟังก์ชันนี้สมมุติว่าถ้าเราทำ 10 ผมจะได้ผลลัพธ์ถ้าผม 15

09:20.700 --> 09:27.230
ผมยังได้ผลลัพธ์

09:27.230 --> 09:28.570
ถ้าฉันทำ 20 ที่นี่

09:29.940 --> 09:30.300
เอาล่ะ

09:30.300 --> 09:33.120
มันเริ่มที่จะใหญ่ขึ้นเรื่อย ๆ

09:33.230 --> 09:40.530
ฉันทำ 30 ถ้าฉันทำ 40

09:40.550 --> 09:43.810
คุณเห็นว่าใช้เวลาในการคำนวณนานเท่าใด

09:44.030 --> 09:47.960
เพราะความซับซ้อนของเวลาของเราเพิ่มมากขึ้นเรื่อย ๆ

09:48.070 --> 09:55.990
ถ้าฉันทำสี่สิบสามตอนนี้คุณจะเห็นว่าเรากำลังรอและรอและรอการคำนวณที่จะเกิดขึ้น

09:56.090 --> 10:01.610
และในที่สุดเบราว์เซอร์ก็มาพร้อมกับการคำนวณเป็นคำถามโบนัสและคิดว่าต้องคำนวณ Fibonacci 43

10:01.610 --> 10:05.770
จำนวนเท่าใด

10:07.130 --> 10:17.590
แม้ว่าอาจจะอ่านได้มากกว่านี้ก็ไม่ใช่วิธีแก้ปัญหาในอุดมคติเพราะคุณสามารถเห็นความซับซ้อนครั้งใหญ่ที่ยิ่งใหญ่

10:17.750 --> 10:23.310
และนี่คือสิ่งที่คุณอาจถูกถามในการสัมภาษณ์และฉันรู้ว่าคุณกำลังคิดอะไรอยู่

10:23.620 --> 10:28.210
อังเดรคุณเพิ่งสอนเราเกี่ยวกับการเรียกซ้ำและมันก็ไม่ดี

10:28.360 --> 10:30.430
ช้ามันทำให้สับสน

10:30.430 --> 10:33.570
ทำไมฉันถึงต้องการใช้การสอบถามซ้ำ

10:34.480 --> 10:38.290
ในวิดีโอหน้าฉันจะพูดถึงการแลกเปลี่ยนนี้

10:38.290 --> 10:42.260
ทำไมคุณถึงต้องใช้การเรียกซ้ำผ่านสิ่งที่เป็นลำไส้อักเสบ

10:43.470 --> 10:46.190
ทำไมคนที่มีสติจะทำเช่นนั้น

10:46.530 --> 10:54.530
และตามที่คุณทราบมีข้อดีและข้อเสียและตามความเป็นจริงแล้วฟังก์ชั่นเช่นนี้เช่น

10:54.530 --> 11:05.010
Fibonacci Sequence และการเรียกซ้ำสามารถทำได้โดยใช้การเขียนโปรแกรมแบบไดนามิกและท่องจำ

11:05.110 --> 11:12.810
ในตอนท้ายของหลักสูตรนี้และเราจะกลับไปที่สิ่งนี้ แต่ในที่สุดเราก็ตอบคำถามในวิดีโอหน้า

11:13.030 --> 11:18.730
ทำไมคุณถึงใช้การเรียกซ้ำมากกว่าสิ่งที่เกิดซ้ำ

11:18.780 --> 11:20.320
ฉันจะดูในถัดไป

11:20.440 --> 11:20.700
เบบัย
