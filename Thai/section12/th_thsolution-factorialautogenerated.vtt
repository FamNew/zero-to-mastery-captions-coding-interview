WEBVTT

00:00.980 --> 00:01.820
ยินดีต้อนรับกลับ.

00:02.190 --> 00:20.940
ลองเริ่มด้วยวิธีการวนซ้ำที่ไม่มีการเรียกซ้ำถ้าเราต้องการเรียกใช้ฟังก์ชันสมมติว่าหา factorial iterative

00:20.940 --> 00:33.510
ห้าในขณะที่เราสามารถสร้างตัวแปรสมมุติว่ามะเร็งและตอนนี้คำตอบนี้จะเป็นหนึ่ง ทำเพื่อวนจะบอกว่าให้ฉันมีค่าใช้จ่ายเป็นศูนย์หรือในกรณีของเราเพื่อลดความซับซ้อนของสิ่งที่

00:33.570 --> 00:50.580
ลองเริ่มที่สองแล้วฉันจะอธิบายในวินาทีทำไมเราถึงต้องการเริ่มสองเพื่อบอกว่าฉันน้อยกว่าจำนวนแล้วเราจะเพิ่มขึ้นทีละ 1

00:50.640 --> 00:55.480
ตอนนี้เราเริ่มเพิ่มทำไม

00:55.600 --> 00:57.510
คุณอาจสังเกตเห็นทางลัดที่นี่

00:58.250 --> 01:08.520
1 แฟคทอเรียลเป็นเพียงหนึ่งสองแฟคทอเรียลคือสองคูณ 1 ซึ่งก็แค่สอง

01:08.560 --> 01:11.210
ดังนั้นสองบิตสุดท้ายนี้

01:11.290 --> 01:22.890
หากมีคนพูดว่าแฟคทอเรียลหนึ่งหรือสองแฟกทอเรียลซึ่งเป็นเพียงแค่คืนค่าจำนวนที่พวกเขาป้อนเพราะไม่มีการคำนวณจริงที่เราต้องทำ

01:22.960 --> 01:36.200
นี่คือทางลัดเล็กน้อยดังนั้นเราจึงหลีกเลี่ยงการวนซ้ำเป็นพิเศษ แต่เพียงบอกว่าถ้าจำนวนที่ผู้ใช้ป้อนคือสมมุติว่า 2

01:36.200 --> 01:39.750
นั่นก็คือสองไม่มากกว่าเลขสอง

01:41.080 --> 01:49.960
วิธีที่เรามีตอนนี้ถ้ามีคนเข้ามาหาแฟคทอเรียลแบบวนซ้ำ 2

01:49.990 --> 02:04.530
เราจะคืนค่า 1 แต่เราสามารถบอกได้ว่าการตรวจสอบเงื่อนไขอย่างง่าย ๆ บอกว่าถ้าจำนวนเท่ากับสอง

02:04.630 --> 02:16.740
ดังนั้นถ้าฉันวิ่งฟังก์ชั่นนี้และบอกว่าฉันจะได้สองถ้าฉันบอกว่าฉันได้หนึ่งและมีการตรวจสอบอื่น ๆ ที่เราสามารถทำได้อย่างชัดเจน

02:17.180 --> 02:19.490
แต่สำหรับกรณีของเรามันดีพอ

02:19.490 --> 02:22.270
ลองดูสิ่งที่เราสามารถทำได้ภายในที่นี่

02:23.270 --> 02:33.740
วิธีการทำงานของแฟกทอเรียลคือการบอกคำตอบก็จะเท่ากับคำตอบคูณด้วย

02:33.960 --> 02:41.950
ดังนั้นถ้าฉันคลิก Quraan ที่นี่และทำห้าฉันได้ 24

02:42.190 --> 02:50.970
ซึ่งจริงๆแล้วไม่ใช่คำตอบที่ถูกต้องเพราะห้าคูณสี่คือ 20 คูณสามสูงกว่า 24 อย่างชัดเจน

02:51.370 --> 02:58.900
และนั่นเป็นเพราะความผิดพลาดเล็กน้อยที่นี่เราต้องการตรวจสอบให้แน่ใจว่านี่เท่ากับเพราะเราต้องการรวมหมายเลขห้า

02:59.260 --> 03:09.800
ดังนั้นถ้าฉันวิ่งอีกครั้งฉันจะได้ร้อยและยี่สิบซึ่งเป็นคำตอบที่ถูกต้องห้าครั้งสี่ครั้งคือ 20 ครั้ง

03:09.940 --> 03:20.940
คูณสามเป็น 60 คูณสองคือ 120 คูณหนึ่งคูณ 120

03:21.280 --> 03:24.650
หวังว่าคุณจะได้คำตอบที่ถูกต้อง

03:25.570 --> 03:27.540
เกี่ยวกับวิธีแบบเรียกซ้ำ

03:29.750 --> 03:42.550
ในเวอร์ชันแบบเรียกซ้ำเราจะทำการตรวจสอบอย่างง่าย ๆ ว่าหมายเลขนั้นเท่ากับ 2 และเราสามารถทำการตรวจสอบอื่น ๆ ได้เช่นกัน

03:42.570 --> 03:46.590
แต่นั่นก็เพียงพอแล้วสำหรับเราที่จะสร้างกรณีพื้นฐาน

03:46.590 --> 03:55.570
ดังนั้นถ้าจำนวนเป็น 2 เราจะกลับไปที่นั่นคือกรณีฐานของเรา

03:55.600 --> 03:57.120
นั่นคือวิธีที่เราหยุด

03:57.190 --> 04:09.360
ต่อไปเราจะคืนค่าเวอร์ชันเรียกซ้ำของเราซึ่งจะเป็นจำนวนครั้งที่ฟังก์ชั่น

04:09.470 --> 04:16.050
และในฟังก์ชั่นนี้เราจะบอกว่าจำนวนลบหนึ่ง

04:16.460 --> 04:17.830
และนั่นคือกุญแจสำคัญที่นี่

04:18.020 --> 04:25.500
เราต้องการลดระดับลงเรื่อย ๆ จนกว่าเราจะตีเคสพื้นฐาน

04:25.520 --> 04:41.570
ดังนั้นถ้าฉันวิ่งไปที่นี่ลองทำซ้ำในเวลานี้ฉันจะเลื่อนมันขึ้นมาตรงนี้และถ้าฉันวิ่งฉันก็มี 120

04:41.750 --> 04:44.380
และนี่เป็นเรื่องยากเล็กน้อยที่จะปิดล้อมใจคุณ

04:44.450 --> 04:52.190
ดังนั้นคุณอาจต้องการคัดลอกรหัสนี้และเปิดเครื่องมือนักพัฒนาซอฟต์แวร์ของ Google Chrome อย่างที่ฉันแสดงให้คุณเห็นและไปทีละขั้นตอน

04:52.280 --> 04:57.680
แต่ถ้าเราเริ่มด้วยเลขห้าตรงนี้ก็จะเท่ากับห้า

04:57.750 --> 04:58.280
เลขที่

04:58.400 --> 05:11.330
จากนั้นเราจะบอกว่าแฟคทอเรียลห้าเท่าเป็นคำตอบของเราเหมือนแผนภาพที่ฉันแสดงให้คุณ

05:11.740 --> 05:22.810
และเราจะดำเนินต่อไปเรื่อย ๆ จนกว่าเราจะไปถึงกรณีพื้นฐานของจำนวนนั้นเท่ากับ

05:22.930 --> 05:29.430
ทีนี้คุณคิดว่าความซับซ้อนของเวลาของฟังก์ชันทั้งสองนี้คืออะไร

05:30.590 --> 05:38.740
ทีนี้อันหนึ่งใช้สำหรับ for loop โดยที่ loop เป็นหมายเลขที่เกี่ยวข้อง

05:39.020 --> 05:44.970
และเรากำลังทำช็อตคัตเล็กน้อยที่นี่ดังนั้นมันจึงน้อยกว่าในทางเทคนิคและเนื่องจากกฎใหญ่ของเรานี้จึงยังคงเอาชนะฟังก์ชัน

05:45.140 --> 05:52.730
recursive ทั้งหมดได้

05:52.750 --> 05:55.280
ถ้าเราดูที่นี่เรากำลังวนรอบ

05:55.330 --> 05:56.540
กี่ครั้ง.

05:57.130 --> 06:03.640
ทีนี้เรากำลังเรียกฟังก์ชั่น function หา factorial

06:03.700 --> 06:05.760
แบบเรียกซ้ำแบบเรียกซ้ำด้วยจำนวนครั้งเดียว

06:05.770 --> 06:12.350
ดังนั้นนี่จะกลายเป็นว่าถ้าคุณมีคำถามนี้

06:12.370 --> 06:13.080
ทำได้ดีมาก

06:13.090 --> 06:14.010
มันเป็นเรื่องที่ยาก

06:14.020 --> 06:17.430
หากคุณไม่ได้กังวลเราก็มีอีกคนหนึ่งที่กำลังจะมาถึง

06:17.500 --> 06:18.830
ฉันจะดูในถัดไป

06:18.960 --> 06:19.190
Babai
