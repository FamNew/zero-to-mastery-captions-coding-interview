WEBVTT

00:01.480 --> 00:10.370
เพื่อที่จะเข้าใจคุณค่าของโครงสร้างข้อมูลอย่างแท้จริงเราต้องลงลึกเข้าไปในวิธีการทำงานของคอมพิวเตอร์ในระดับพื้นฐาน

00:11.620 --> 00:18.960
เพื่อให้คอมพิวเตอร์เรียกใช้โค้ดเขาต้องการติดตามสิ่งต่าง

00:19.000 --> 00:28.530
ๆ เช่นตัวแปรเช่นสตริงตัวเลขหรืออาร์เรย์ตัวแปรเหล่านี้จะถูกเก็บไว้ในสิ่งที่เราเรียกว่าหน่วยความจำเข้าถึงโดยสุ่มหรือแรมสั้น ๆ

00:28.560 --> 00:30.570
นั่นเป็นวิธีที่โปรแกรมทำงาน

00:30.690 --> 00:39.000
เราจำสิ่งนี้ได้จากวิดีโอที่มีความซับซ้อนของพื้นที่ด้านบนซึ่งเรามีพื้นที่เก็บข้อมูลที่เราเก็บสิ่งต่าง

00:39.000 --> 00:51.470
ๆ เช่นไฟล์วิดีโอไฟล์เพลงไฟล์เอกสารของเรา

00:52.290 --> 00:56.150
การจัดเก็บข้อมูลถาวรหรือจะเรียกว่าถาวร

00:56.190 --> 01:02.460
ดังนั้นเมื่อคุณปิดแล็ปท็อปหรือคอมพิวเตอร์ของคุณมันจะยังคงอยู่เมื่อคุณเปิดเครื่องอีกครั้งใน RAM

01:02.460 --> 01:06.310
คุณจะสูญเสียหน่วยความจำเมื่อคอมพิวเตอร์ปิด

01:07.370 --> 01:10.150
ดังนั้นทำไมเราไม่ใช้พื้นที่เก็บข้อมูลเสมอ

01:10.610 --> 01:12.360
ดังนั้นเราจะไม่สูญเสียข้อมูลใด ๆ

01:12.830 --> 01:21.470
ปัญหาก็คือที่เก็บข้อมูลถาวรนั้นช้าเพราะคุณเห็นคอมพิวเตอร์ทำงานโดย C พี คุณสามารถนึกถึง

01:22.000 --> 01:26.820
C-p ในฐานะคนงานตัวเล็ก ๆ ที่ทำการคำนวณทั้งหมดที่เราต้องการ

01:27.000 --> 01:29.530
มันทำงานได้จริงในคอมพิวเตอร์ของเรา

01:29.880 --> 01:40.020
และสิ่งนี้คุณต้องการเข้าถึง RAM และที่เก็บข้อมูล แต่สามารถเข้าถึง RAM และข้อมูลและ RAM

01:40.020 --> 01:42.060
ได้เร็วขึ้นมาก

01:42.610 --> 01:49.930
แต่ให้ฉันยกตัวอย่างให้คุณดูราวกับว่าเรากำลังใช้ Google เมื่อเราเรียกใช้ Google Chrome สำหรับเบราว์เซอร์ที่เบราว์เซอร์ Google

01:51.280 --> 01:54.390
Chrome มีรหัส

01:54.400 --> 01:58.830
ตอนนี้ที่นี่ฉันได้ทำให้มันง่ายขึ้นและเรามีตัวแปร A เท่ากับหนึ่ง

01:58.870 --> 02:08.150
เราเพียงแค่กำหนดตัวแปรนี้ แต่เราสามารถจินตนาการได้ว่าเรามีโค้ดหลายร้อยหรือหลายพันบรรทัดของ Google Chrome

02:08.380 --> 02:16.210
ตอนนี้เพื่อให้คอมพิวเตอร์ของเราสามารถเรียกใช้ Google Chrome ได้เราจะเรียกใช้ CPI เพื่อดำเนินการดังกล่าว

02:16.260 --> 02:24.320
ตอนนี้เมื่อมีการประกาศตัวแปรในสมมติว่าสคริปต์เรียกใช้ Google Chrome

02:24.320 --> 02:28.470
ก็จะเก็บไว้ในหน่วยความจำและหน่วยความจำเข้าถึงโดยสุ่มของเรา

02:28.650 --> 02:35.250
แต่เมื่อเราปิดหรือปิด Google Chrome เราต้องการที่จะสามารถเปิดได้อีกครั้ง

02:35.250 --> 02:36.060
ขวา.

02:36.510 --> 02:40.440
นั่นคือสิ่งที่เราทำเมื่อเราบันทึกแอปพลิเคชันบนคอมพิวเตอร์ของเรา

02:40.500 --> 02:51.260
เราบันทึกลงในที่เก็บข้อมูลเพื่อที่ครั้งต่อไปที่เราเปิด Google Chrome CPQ

02:51.590 --> 02:54.950
จะจับโปรแกรมจากที่จัดเก็บเพื่อให้สามารถใช้งานได้อีก

02:55.160 --> 03:02.240
และสำหรับ Google Chrome

03:02.360 --> 03:06.440
ที่จะทำงานได้อย่างรวดเร็วและเรียกใช้สคริปต์ขนาดเล็กมันจะเก็บข้อมูลนั้นและหน่วยความจำเข้าถึงโดยสุ่มเราสามารถเห็นสิ่งนี้ในคอมพิวเตอร์ของเรา

03:08.010 --> 03:16.050
ถ้าฉันไปที่ Mac

03:16.050 --> 03:28.140
เครื่องคอมพิวเตอร์ของฉันเราจะเห็นว่าเรามีโปรเซสเซอร์ซึ่งเป็น CPQ ของฉันเรามีหน่วยความจำของฉันซึ่งเป็น RAM ของฉันและถ้าฉันไปที่จัดเก็บ

03:28.390 --> 03:36.430
ดังนั้นคุณสามารถนึกถึง RAM

03:37.570 --> 03:43.480
ในคอมพิวเตอร์ว่าเป็นพื้นที่เก็บข้อมูลขนาดใหญ่เช่นอัตราโครงสร้างข้อมูลพื้นที่เก็บข้อมูลขนาดใหญ่นี้มีชั้นวางของที่มีหมายเลข

03:44.490 --> 04:07.000
เราเรียกที่อยู่หรือที่อยู่เหล่านี้และมันเป็นชั้นวางที่ใหญ่มากจริงๆที่เก็บข้อมูลจำนวนมากและช่วยให้เราสามารถเรียกใช้โปรแกรมบนคอมพิวเตอร์ของเราตอนนี้แต่ละชั้นเหล่านี้เก็บสิ่งที่เราเรียกว่าแปดบิตหรือตัวเลข

04:07.170 --> 04:21.670
หากคุณเห็นที่นี่หนึ่งสองสามสี่ห้าหกเจ็ดแปดแต่ละหมายเลขเหล่านี้เป็นบิตและบิตเป็นสวิตช์ไฟฟ้าขนาดเล็กที่สามารถเปิดหรือปิด

04:21.940 --> 04:30.330
แต่แทนที่จะเรียกหรือปิดเราเรียกมันว่า 1 หรือ 0 และ 8 บิตเรียกว่า byte

04:30.550 --> 04:41.910
แต่ละชั้นมีที่เก็บข้อมูลหนึ่งไบต์และ

04:42.450 --> 04:55.840
CPQ เชื่อมต่อกับสิ่งที่เรียกว่าตัวควบคุมหน่วยความจำและตัวควบคุมหน่วยความจำทำการอ่านหน่วยความจำนี้จริงรวมทั้งการเขียนหน่วยความจำจริงเพราะบางครั้งชั้นวางอาจว่างเปล่าและไม่มีอะไรเลย

04:55.880 --> 05:06.700
ตอนนี้การเชื่อมต่อโดยตรงกับ C-p มีความสำคัญเพราะ C-p คุณถาม REM ถึงสิ่งที่อยู่ในชั้นวางเลขศูนย์

05:07.100 --> 05:30.970
และตัวควบคุมหน่วยความจำมีการเชื่อมต่อกับชั้นวางทั้งหมดเหล่านี้อีกครั้งซึ่งสำคัญมากเพราะหมายความว่าเราสามารถเข้าถึงชั้นวางศูนย์และเข้าถึงชั้นวางเจ็ดทันทีหรือหนึ่งหมื่นเจ็ดแสนแปดหมื่นหนึ่งชั้นโดยไม่ต้องปีนลงหรือก้าวลง .

05:32.160 --> 05:35.190
นั่นคือความหมายของชื่อหน่วยความจำเข้าถึงโดยสุ่ม

05:35.190 --> 05:41.160
เราสามารถเข้าถึงหน่วยความจำได้อย่างรวดเร็วเพราะเรามีการเชื่อมต่อเหล่านี้และแต่ละชั้นที่เราต้องการเราเพียงแค่ต้องรู้ว่าชั้นวางที่เรากำลังมองหาเราสามารถเข้าถึงบิตที่ที่อยู่แบบสุ่มใด

05:41.160 --> 05:48.380
ๆ ในหน่วยความจำทันที

05:48.690 --> 05:57.820
แม้ว่าตัวควบคุมหน่วยความจำนี้สามารถข้ามไปมาระหว่างหน่วยความจำที่ห่างไกลที่อยู่อย่างรวดเร็วโปรแกรมมักจะเข้าถึงหน่วยความจำที่อยู่ใกล้เคียง

05:57.870 --> 06:06.570
ยิ่งข้อมูลใกล้กับ C มากขึ้นเท่านั้น พี คุณและยิ่งน้อยต้องเดินทางให้เร็วขึ้นเท่าที่โปรแกรมสามารถทำงานได้

06:07.570 --> 06:13.040
ดังนั้นคอมพิวเตอร์ถูกปรับเพื่อรับความเร็วเพิ่มพิเศษเมื่ออ่านชุดความจำ

06:13.950 --> 06:22.140
ที่อยู่ใกล้กันเพื่อให้คอมพิวเตอร์เข้าถึงศูนย์และอีกอันหนึ่งนั้นเร็วกว่าคอมพิวเตอร์มาก

06:22.140 --> 06:29.650
สำหรับการเข้าถึง 0 และ 1,000 เพราะสิ่งเหล่านี้อยู่ใกล้กันมาก

06:29.650 --> 06:33.400
และเพื่อเพิ่มประสิทธิภาพนี้ยังมีคอมพิวเตอร์

06:33.670 --> 06:44.000
เราเรียก ACP ว่าเงินสดของคุณโดยที่ CPQ มีหน่วยความจำเล็ก ๆ น้อย ๆ ที่เก็บสำเนาของสิ่งต่างๆ

06:44.810 --> 06:53.310
และนี่เรียกว่าแคชที่จะมาในวันหนึ่งคุณอาจมาที่นี่คือสิ่งที่เรียกว่าแคชแอร์ LRU

06:53.320 --> 07:00.070
ดังนั้นอีกครั้งถ้าเราใช้ Google Chrome เป็นตัวอย่างเราเปิด google

07:00.070 --> 07:08.590
chrome ด้วยสิ่งที่บอกว่าเรามีแอพพลิเคชั่นดาวน์โหลดไว้ในที่เก็บข้อมูล พี คุณโหลดมันขึ้นมาและเพราะเราเคยไปที่ Hacker

07:08.590 --> 07:16.630
News dot com มันจะทำการโหลดข้อมูลสำหรับ Hacker News

07:16.630 --> 07:19.210
นั้นและใส่มันเข้าไปในหน่วยความจำหรืออาจจะเป็นแคชถ้ามันสามารถเก็บได้

07:19.250 --> 07:22.430
เหตุใดจึงมีความสำคัญต่อโครงสร้างข้อมูล

07:25.230 --> 07:30.840
โครงสร้างข้อมูลเป็นวิธีการที่เราจดจำในการจัดเก็บข้อมูล

07:30.840 --> 07:39.830
ตัวอย่างเช่นถ้าเราต้องการเก็บตัวแปร A เท่ากับหนึ่งดีในคอมพิวเตอร์สมัยใหม่ของเราโดยปกติแล้วเราจะแทนจำนวนเต็ม

07:39.980 --> 07:43.530
นั่นคือหมายเลขหนึ่งใน 32 บิต

07:43.670 --> 07:47.250
นั่นคือขนาดบล็อกของ RAM

07:47.450 --> 07:53.670
และด้วยวิธีนี้ในขณะนี้สามารถเป็น 64 บิตพร้อมการอัปเกรดล่าสุดมากขึ้นเรื่อย ๆ

07:54.940 --> 08:06.970
แต่วิธีนี้เราสามารถเก็บหมายเลขหนึ่งไว้ในบล็อกนี้ 32 บิต y 32 บิตเพราะ

08:06.970 --> 08:13.840
8 บิตซึ่งเป็นหนึ่งไบต์คูณหนึ่งสองสามสี่ดังนั้นแปดคูณสี่คือสามสิบสองบิต

08:13.930 --> 08:23.090
เราสามารถเก็บข้อมูล 32 บิตและบิตหนึ่งที่คุณเห็นนี่คือ 0 0 0 0 0 0 0 0 และ 1 ถูกเก็บไว้ในหน่วยความจำตอนนี้ 0

08:23.270 --> 08:28.460
1 2 3 หรือที่อยู่ 0 1 2 3

08:28.580 --> 08:37.480
ถ้าเรามีตัวแปรอีกตัวเท่ากับ 7 เราจะเก็บมันไว้ในบล็อกถัดไปตรงนี้ในหน่วยความจำของเรา

08:37.590 --> 08:50.570
ในการทำเช่นนี้คุณสามารถคิดได้ว่าระบบที่ 8 นั้นสามารถเก็บข้อมูล 255 บิตได้อย่างไรที่ 16

08:50.570 --> 08:54.670
บิตในขณะที่พวกเขาสามารถเก็บข้อมูลได้มากขึ้น

08:54.920 --> 09:01.670
และตอนนี้เรามีระบบที่ 32

09:01.670 --> 09:14.880
บิตคุณสามารถดูที่นี่ว่าเราสามารถเก็บข้อมูลได้มากมายและถ้าเรามี 64 บิตแทนที่จะเป็นสี่ชั้นวางเล็ก ๆ ตรงนี้

09:15.040 --> 09:23.730
นั่นคือข้อมูลจำนวนมากที่เราสามารถจัดเก็บและยิ่งใหญ่นี่คือข้อมูลที่หลากหลายมากขึ้น

09:23.800 --> 09:25.670
ถ้าเรามีระบบ 8 บิต

09:25.880 --> 09:30.040
จำนวน 256 ที่เราเก็บได้จริงๆ

09:30.070 --> 09:31.680
นั่นเป็นเรื่องยากที่จะทำ

09:31.960 --> 09:35.460
และฉันสามารถแสดงให้คุณเห็นด้วย javascript

09:35.570 --> 09:38.350
คุณเห็นว่ามีบางสิ่งที่เรียกว่าจำนวนเต็มล้น

09:38.420 --> 09:46.100
ตอนนี้จาวาสคริปต์ทางเทคนิคไม่มีจำนวนเต็มมันมีเพียงสิ่งที่เราเรียกว่า 64 บิตลอย

09:46.100 --> 09:54.940
แต่ความคิดก็คือว่าคอมพิวเตอร์สามารถจัดเก็บข้อมูลจำนวนหนึ่งเท่านั้นดังนั้นการใช้ไวยากรณ์นี้ในจาวาสคริปต์เรามี Mathcad ในขณะนี้

09:54.970 --> 10:00.270
ฐานไปยังอดีตโป๊อยู่ในอำนาจ

10:00.460 --> 10:06.040
นั่นคือพารามิเตอร์แรกคือฐานกำลังของพารามิเตอร์ที่สอง

10:06.130 --> 10:09.160
ดังนั้นเราสามารถสร้างจำนวนมากเช่นคณิตศาสตร์

10:09.220 --> 10:09.690
อำนาจ

10:09.700 --> 10:11.680
ดังนั้น 5 กำลังของ 100

10:11.830 --> 10:14.360
ถ้าฉันรันสิ่งนี้เราจะเห็นตัวเลขตรงนี้

10:14.440 --> 10:19.610
ถ้าผมเพิ่มนี่ให้สมมุติว่า 6 อีกอีกจำนวนมาก

10:19.660 --> 10:28.470
ทีนี้ถ้าฉันก้าวต่อไปและเปลี่ยนมันเป็นหกกำลังของหนึ่งพันเราจะได้อินฟินิตี้

10:28.730 --> 10:30.060
นั่นคืออะไร.

10:30.340 --> 10:38.860
เช่นเดียวกับจำนวนที่มากเกินไปที่จะเก็บใน RAM

10:39.010 --> 10:44.880
ของเราจากนั้นเราจำเป็นต้องแสดงหมายเลขนี้ที่เราไม่สามารถจัดเก็บลงในบางสิ่งที่เป็นรูปธรรม

10:44.920 --> 10:51.850
เราสามารถจัดเก็บข้อมูลได้มากมายและไม่ว่าฉันจะทำให้จำนวนนี้สูงกว่าขีด จำกัด

10:51.850 --> 10:55.960
ที่กำหนดเพียงใดก็ยิ่งใหญ่เพียงแค่บอกว่าไม่มีที่สิ้นสุด

10:56.000 --> 10:56.930
เท่ห์แค่ไหน

10:58.620 --> 10:59.980
ตอนนี้ให้กลับไปที่สไลด์

11:00.950 --> 11:07.880
ฉันแสดงให้คุณเห็นทั้งหมดนี้เพราะประเภทข้อมูลอื่น ๆ

11:07.910 --> 11:16.180
ที่ไม่ใช่ตัวเลขทำงานแบบเดียวกับที่แต่ละประเภทข้อมูลมีจำนวนบิตที่เกี่ยวข้องกับมันและที่ต้องได้รับการจัดเก็บในระบบและระบบจัดสรรหน่วยเก็บข้อมูลแล้ว CPQ อ่านจากหน่วยเก็บข้อมูลนั้น

11:16.660 --> 11:22.760
.

11:22.760 --> 11:28.110
ตอนนี้ฉันจะทิ้งลิงค์ไว้ให้คุณหลังจากวิดีโอนี้เพื่อที่คุณจะได้รับข้อมูลเพิ่มเติมหากคุณต้องการ

11:28.110 --> 11:36.470
เราไม่ต้องการเจาะลึกลงไปในสิ่งนี้ แต่โครงสร้างข้อมูลคือโครงสร้างข้อมูลเป็นการจัดเรียงข้อมูล

11:36.620 --> 11:43.820
คุณสามารถกำหนดวิธีการที่คุณโต้ตอบกับข้อมูลนี้และวิธีการจัดเรียงใน RAM ดังนั้นโครงสร้างข้อมูลใน RAM

11:43.820 --> 11:47.060
จะถูกจัดเรียงติดกัน

11:47.090 --> 11:52.960
บางคนมีการจัดระเบียบแยกจากกันและพวกเขามีข้อดีและข้อเสียต่างกันในการเข้าถึง

11:53.330 --> 11:55.150
และถูกต้อง

11:55.300 --> 12:05.300
เป้าหมายของเราคือลดการดำเนินการที่เราต้องทำเพื่อลด คุณได้รับข้อมูลเพื่อให้คุณเขียนข้อมูล

12:05.520 --> 12:08.730
และนั่นคือสาเหตุที่โครงสร้างข้อมูลมีประสิทธิภาพมาก

12:08.730 --> 12:15.660
เรากำลังคิดเกี่ยวกับระดับต่ำและฉันไม่รู้จักคุณ

12:15.660 --> 12:22.860
แต่สิ่งนี้สำหรับฉันเมื่อฉันเรียนรู้เกี่ยวกับสิ่งนี้น่าตื่นเต้นจริง ๆ

12:22.860 --> 12:30.600
เพราะเรามีวิธีคิดว่าโครงสร้างข้อมูลส่งผลกระทบต่อกระบวนการของคอมพิวเตอร์ของเราจริง ๆ สามารถใช้สิ่งที่เรารู้เกี่ยวกับคอมพิวเตอร์ในขณะนี้เพื่อเขียนโค้ดที่ยอดเยี่ยม

12:30.660 --> 12:31.610
ฉันจะดูในวิดีโอหน้า
