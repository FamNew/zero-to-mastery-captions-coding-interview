WEBVTT

00:00.890 --> 00:08.540
A co z głębią pierwszego wyszukiwania na wykresach, którego możesz nie znać, ale właśnie nauczyłeś się,

00:08.840 --> 00:16.970
jak rozwiązywać labirynt za pomocą programu, ponieważ pierwsze wyszukiwanie śmierci jest dokładnie takie, jak rozwiązywanie problemu z labiryntem.

00:17.300 --> 00:23.360
Jeśli kiedykolwiek zrobiłeś prawdziwy labirynt życia lub spojrzałeś na program, który próbuje rozwiązać,

00:23.360 --> 00:30.560
którą drogą podążać, to przejść tak głęboko, jak to tylko możliwe, a kiedy uderzysz w blokadę drogi

00:30.560 --> 00:37.370
lub miejsce, w którym nie możesz już iść cofasz się i znajdujesz inną trasę, a

00:37.370 --> 00:44.850
następnie przechodzisz do tyłu, aż znajdziesz żądany węzeł lub akceptujesz labirynt i to jest piękno śmierci dla wyszukiwania.

00:44.920 --> 00:50.350
Możesz teraz zaimplementować algorytm, który rozwiązuje zagadkę labiryntu.

00:50.410 --> 00:52.980
Czy to nie jest takie fajne, jak tutaj.

00:53.020 --> 01:02.980
Jeśli zrobimy def pierwsze wyszukiwanie, powiedzmy, że zaczynamy od numeru jeden, a 10 to akceptujemy lub dziewięć jest

01:02.980 --> 01:03.990
wyjściem.

01:04.360 --> 01:12.250
I faktycznie nie będzie działać, ponieważ w przeciwieństwie do naszego poprzedniego wykresu, który był nieukierunkowany, który ma oba kierunki,

01:12.250 --> 01:14.520
mogę jechać tam iz powrotem.

01:14.560 --> 01:19.220
Ten jest skierowanym wykresem, który ma określone kierunki, którymi może się kierować.

01:19.420 --> 01:21.680
Zróbmy od zera do dziewiątki.

01:21.880 --> 01:28.230
Jeśli zrobię śmierć dla wyszukiwania i zrobię 9 lub zaczniemy od zera, próbując znaleźć dziewięć.

01:28.420 --> 01:32.140
Tak jak patrząc przez labirynt, idę tutaj, idę tutaj.

01:32.290 --> 01:39.460
Wciąż przechodzę przez moje dzieci, a potem staram się iść tak głęboko, jak tylko potrafię i udało mi się wydostać

01:39.460 --> 01:43.180
z labiryntu, zanim nawet przeszukuję 6 i 5 tutaj.

01:44.370 --> 01:48.500
I oczywiście ten algorytm działa, ponieważ mogę powiedzieć, żeby przestał o dziewiątej.

01:48.630 --> 01:52.730
Ale widzisz, jak to było dokładnie jak rozwiązywać labirynt.

01:53.720 --> 01:57.030
I dlatego używamy rekurencji dla śmierci, by znaleźć prawo do wyszukiwania.

01:58.120 --> 02:06.220
Idea wycofywania po ślepym zaułku, a następnie powtarzania chodzenia po innej ścieżce jest po prostu rekursją, każdy krok mniejszy

02:07.260 --> 02:12.470
od drugiego, a następnie wracamy, a następnie robimy to samo w kółko.

02:13.430 --> 02:20.340
Ideą śmierci dla poszukiwań jest to, że naprawdę dobrze jest mówić, że ścieżka istnieje.

02:20.420 --> 02:29.960
Nie informuje nas o najkrótszej ścieżce, ale o tym, czy istnieje, i wykorzystuje pierwsze wyszukiwanie mniejszej głębokości pamięci.

02:30.000 --> 02:38.280
Jedną wadą jest to, że jeśli masz naprawdę bardzo głęboki wykres, to może on stać się bardzo powolny,

02:38.370 --> 02:46.440
ponieważ im głębszy wykres, tym bardziej rekursywny wywołuje więcej złożoności przestrzeni, którą dodajesz, ponieważ musimy śledzić te

02:46.440 --> 02:48.900
wywołania funkcji na stosie.
