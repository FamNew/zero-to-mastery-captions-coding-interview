WEBVTT

00:02.030 --> 00:09.740
A questo punto, che cosa è una buona cocaina, dovresti essere in grado di parlare un po 'soprattutto del diritto scalabile.

00:09.980 --> 00:16.570
Voglio dire leggibile di cui parleremo nella prossima sezione ma scalabile abbiamo capito che era grande O

00:17.170 --> 00:17.890
giusto.

00:18.320 --> 00:27.290
Bene, ecco la cosa non mi odio ma potrei aver mentito leggermente o semplificato le cose ma non così tanto

00:27.290 --> 00:33.920
non preoccuparti che Bouldon che quando dico scalabile ci siano in realtà due cose che

00:33.950 --> 00:36.260
vogliamo considerare come ingegneri.

00:36.260 --> 00:38.430
Uno è la velocità.

00:38.480 --> 00:41.090
Questo è quello di cui abbiamo parlato fino ad ora.

00:41.180 --> 00:45.210
Quanto è veloce il nostro runtime sul codice.

00:45.290 --> 00:49.730
Quanto tempo ci vuole per una funzione da eseguire.

00:49.730 --> 00:52.820
Quante operazioni costa.

00:53.270 --> 00:58.850
Bene, c'è un altro aspetto quando si tratta di macchine con risorse preziose.

00:58.850 --> 01:06.860
Uno è il tempo e la velocità del nostro codice e l'altro è la memoria.

01:06.860 --> 01:11.800
Vedi i computer hanno una memoria limitata.

01:11.860 --> 01:17.860
Ai tempi in cui i computer erano appena nati, la memoria era molto costosa.

01:17.860 --> 01:19.560
Ne abbiamo solo un po '.

01:19.870 --> 01:25.280
E col passare del tempo abbiamo sempre più memoria ma non è infinita.

01:26.070 --> 01:36.090
I nostri computer funzionano in base alla velocità, che in genere è dettata dal CPQ e dalla memoria in base alla quantità di memoria, ad

01:36.330 --> 01:40.000
esempio RAM e memoria ad accesso casuale del computer.

01:40.260 --> 01:43.810
E quelle sono due risorse preziose.

01:43.860 --> 01:46.110
Quindi, come possiamo parlare della memoria.

01:46.110 --> 01:47.770
Abbiamo parlato di velocità.

01:47.820 --> 01:53.010
Per quanto riguarda la memoria e la buona notizia è che la memoria è abbastanza semplice e non

01:53.190 --> 02:00.240
è complicata come la velocità e non ci vorrà molto per imparare quanto abbiamo sulla velocità in questo momento, a quale codice è meglio

02:00.240 --> 02:05.820
rispondere con i tre pilastri del codice qualcosa che voglio che porti con te per il resto della tua

02:05.870 --> 02:10.440
carriera e qualcosa che ti farà crescere come ingegnere perché d'ora in poi quando scrivi il

02:10.440 --> 02:12.810
codice avrai in mente queste tre cose.

02:12.810 --> 02:20.890
Uno sta per scrivere un codice pulito leggibile che altri possano leggere che sia gestibile.

02:20.910 --> 02:30.270
L'altro è la velocità del tipo di codice che chiamiamo complessità temporale ha una complessità temporale grande che

02:30.270 --> 02:31.440
è efficiente.

02:31.440 --> 02:33.020
Bilancia bene.

02:33.230 --> 02:39.910
Ma parleremo rapidamente di questo terzo pilastro e questa è la memoria.

02:40.010 --> 02:44.700
Qual è l'utilizzo della memoria del codice se utilizza molta memoria.

02:44.780 --> 02:45.560
Questo non è buono.

02:45.590 --> 02:49.430
Potremmo avere memoria limitata sulla nostra macchina con questo.

02:49.520 --> 02:54.830
Usiamo ancora il big-O per parlare della complessità dello spazio.

02:54.830 --> 02:58.910
La stessa notazione ma argomento diverso.

02:58.910 --> 03:00.080
Uno è lo spazio.

03:00.080 --> 03:02.220
L'altro è TIME One è la velocità.

03:02.300 --> 03:04.670
L'altro è memoria.

03:04.670 --> 03:11.610
Vi darò una piccola anteprima in anteprima della maggior parte delle soluzioni di codice di programmazione.

03:11.610 --> 03:14.830
Di solito c'è un compromesso tra velocità e memoria.

03:14.830 --> 03:22.220
Vuoi che le cose vadano più velocemente, quindi potresti dover sacrificare più memoria per risparmiare meno memoria.

03:22.330 --> 03:27.120
Bene, allora potresti dover sacrificare con maggiore velocità.

03:27.290 --> 03:31.040
Entriamo nel nocciolo duro di come misuriamo la complessità dello spazio.
