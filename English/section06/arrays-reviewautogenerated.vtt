WEBVTT

00:01.530 --> 00:06.630
It's time to celebrate because you just finished your first data structure and they're going to get

00:06.630 --> 00:07.850
more and more fun.

00:08.070 --> 00:14.510
But you see here that we've learned to complete our mental model of data structures.

00:14.670 --> 00:20.490
I promised you that by the end of this course this whole diagram is going to make sense and we've finished

00:20.520 --> 00:21.770
a small part of it.

00:21.870 --> 00:32.710
The array's we talked about static and dynamic arrays we talked about the big O complexity and how dynamic

00:32.710 --> 00:43.840
arrays can sometimes have O and pens because while sometimes we have to double up or expand our memory

00:44.560 --> 00:51.100
we also talked about how strings and questions regarding strings can be treated very similar to array

00:51.100 --> 00:52.120
questions.

00:52.760 --> 00:58.760
Where you just convert them to an array and then join them back up and return a string.

00:58.800 --> 01:05.090
Answer that need and there's a few other points for arrays that we're going to talk about when we get

01:05.210 --> 01:06.430
into algorithms.

01:06.650 --> 01:14.930
But by now you should take a look at the bego cheat sheet and understand why the array data structure

01:15.170 --> 01:17.700
has these big numbers.

01:18.110 --> 01:22.890
And understand when an array is a good thing to use.

01:22.940 --> 01:28.310
One thing you'll note when it comes to race especially when we get to algorithms is that they are really

01:28.310 --> 01:37.130
really good at having sorted data when it comes to sorting arrays are awesome because they're in memory

01:37.130 --> 01:40.820
in sequential order according to their index.

01:40.820 --> 01:45.740
Now before I go onto the slide you composed the video.

01:45.740 --> 01:49.940
Think about when you would want to use an array when you would it.

01:50.180 --> 01:54.410
Because in about five seconds I'm going to show you the pros and cons.

01:54.530 --> 02:00.850
So pause the video and the answer to when you should use an array well.

02:01.050 --> 02:02.250
Here it is.

02:02.250 --> 02:05.310
Arrays are great for fast lookups.

02:05.400 --> 02:10.420
That is just accessing information where you know which index you want to look at.

02:10.740 --> 02:12.840
It's really fast that push and pop.

02:12.840 --> 02:18.770
So I think things at the end of an array or taking things out at the end of the array.

02:19.020 --> 02:24.810
And of course because it's ordered having something that is ordered and close to each other in memory

02:25.200 --> 02:27.330
makes it really fast.

02:27.460 --> 02:34.770
However it has slow inserts and deletes because we have to shift to race whenever it's not at the very

02:34.770 --> 02:36.300
end of the array.

02:36.420 --> 02:41.590
And then finally if using static arrays it's fixed size.

02:41.610 --> 02:48.630
That means sometimes you have to declare the memory ahead of time and how large of an array you want.

02:48.630 --> 02:55.460
But that can be avoided if we use some of the more modern languages that have dynamic arrays.

02:55.530 --> 03:01.980
Also I just realized that this smiley face kind of looks like a crazy person but this is meant to be

03:01.980 --> 03:02.380
good.

03:02.400 --> 03:03.240
This is good.

03:03.360 --> 03:05.330
This scary little icon.

03:05.370 --> 03:06.510
That's bad.

03:07.110 --> 03:07.830
OK.

03:08.290 --> 03:10.340
I think we get it now.

03:10.360 --> 03:14.590
We're going to come back to raise because a lot of other data structures we're going to talk about later

03:14.590 --> 03:19.120
on like queues and stacks are related to race.

03:19.300 --> 03:25.370
But for now I want to get into other data structures because we still have a few to go through.

03:25.430 --> 03:26.440
I'll see in the next one.
